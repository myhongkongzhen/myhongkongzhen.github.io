<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[using hexo to create github blog]]></title>
    <url>%2Farchives%2Ftechnology%2F2017%2F08%2F01%2Fusing-hexo-to-create-github-blog.html</url>
    <content type="text"><![CDATA[Using hexo to create github blog Prepare working Git Node.js &amp; npm &amp; hexo Init hexo working space 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647hexo init myhongkongzhen.github.io#001_hexo_init#----------------------------------------------------cd myhongkongzhen.github.iogit initgit add .git ci -m"init hexo blog"#002_git_init#----------------------------------------------------git submodule add https://github.com/myhongkongzhen/hexo-theme-next.git themes/next#003_add_hexo_theme_nextcd themes\nextgit remote -v#004_remote_v_01git remote add upstream https://github.com/iissnan/hexo-theme-next.gitgit remote -v#004_remote_v_02git fetch upstreamgit merge upstream/master#004_remote_v_03.jpg#----------------------------------------------------git taggit co -b mystyle v5.1.1#005_change_release_version_next#----------------------------------------------------cd myhongkongzhen.github.iogit remote add origin https://github.com/myhongkongzhen/hexo_blog_src.gitgit push -u origin master#006_add_remote_githubhexo s -g --debug -p8888#start hexo blog local server#007_start_hexo#----------------------------------------------------npm install hexo-deployer-git --save # deploy to githubnpm install hexo-filter-plantuml --save # plantumlnpm install hexo-generator-feed --save # feednpm install hexo-generator-searchdb --save # local searchnpm i --save hexo-wordcount # wordcount]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML class diagram]]></title>
    <url>%2Farchives%2Ftechnology%2F2017%2F07%2F31%2FUML-class.html</url>
    <content type="text"><![CDATA[Unified Modeling Language UML class diagram IMG download =&gt; uml_class_extends_implements IMG download =&gt; uml_class_dependency IMG download =&gt; uml_class_association_aggregation IMG download =&gt; uml_class_composition]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK_Stage review_008]]></title>
    <url>%2Farchives%2Ftechnology%2F2017%2F07%2F31%2FELK-Stage-review-008.html</url>
    <content type="text"><![CDATA[Stage review Elasticsearch core structure IMG download =&gt; ES core structure]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK_batch search_007]]></title>
    <url>%2Farchives%2Ftechnology%2F2017%2F07%2F30%2FELK-batch-search-007.html</url>
    <content type="text"><![CDATA[Batch query mget _mget 123456789101112131415GET /_mget # different index &amp; type&#123; "docs" : [ &#123; "_index" : "test_index", "_type" : "test_type", "_id" : "1" &#125;, &#123; "_index" : "test_index", "_type" : "test_type", "_id" : "2" &#125; ]&#125; 12345678910111213GET /test_index/_mget # the same index and different type&#123; "docs" : [ &#123; "_type" : "test_type", "_id" : 1 &#125;, &#123; "_type" : "test_type", "_id" : 2 &#125; ]&#125; 1234GET /test_index/test_type/_mget # the same index &amp; type&#123; "ids": [1, 2]&#125;]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK_Concurrent conflict_006]]></title>
    <url>%2Farchives%2Ftechnology%2F2017%2F07%2F30%2FELK-Concurrent-conflict-006.html</url>
    <content type="text"><![CDATA[Pessimistic lock Relational Database ex : MySQL Optimistic lock ex : Elasticsearch Lock Pessimistic lock Any time it lock, only one thread can operate data. Optimistic lock Any time it unlock, every thread can operate data, but it has a version info. _version internal _version12345678910111213&#123; "_index": "test_index", "_type": "test_type", "_id": "4", "_version": 1, # any operating , plus 1 (include DELETE, Not physically deleted) "result": "created", "_shards": &#123; "total": 2, "successful": 1, "failed": 0 &#125;, "created": true&#125; 1234PUT /test_index/test_type/7?version=2&#123; "test_field":"test field 7.1"&#125; external version ?version=1&amp;version_type=external es, _version=1, ?version=1 ==&gt; update success es, _version=1, ?version &gt;1 &amp;version_type=external ==&gt; update success Partial update &amp;&amp; Optimistic lock retry strategy retry_on_conflict : retry times 1POST /test_index/test_type/id/_update?retry_on_conflict=5&amp;version=6]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK_Document core idea_005]]></title>
    <url>%2Farchives%2Ftechnology%2F2017%2F07%2F30%2FELK-Document-core-idea-005.html</url>
    <content type="text"><![CDATA[document core metadata _index _type _id _source 12345678910&#123; "_index": "test_index", "_type": "test_type", "_id": "1", "_version": 1, "found": true, "_source": &#123; "test_content": "test test" &#125;&#125; _index One document is in which index. The different data(field) need be in different index. _type One document belongs to which type in index. _id The unique identity of the document. Manual create document id. Import other system data to ES. 1234PUT /test_index/test_type/2&#123; "test_content" : "my test"&#125; Auto create document id. length : 20 url security : base64 GUID1234POST /test_index/test_type&#123; "test_content" : "my test" &#125; _source 1GET /test_index/test_type/1 1GET /test_index/test_type/1?_source=test_field1,test_field2 Document replacement The same as creating the document if _id exists, then it will be full replacement. if not, create new document.1234PUT /test_index/test_type/4 &#123; "test_field6":"test field 6" &#125; Forced replacement PUT /index/type/id?op_type=create PUT /index/type/id/_create Delete document 1DELETE /test_index/test_type/4]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK_Elasticsearch core structure_004]]></title>
    <url>%2Farchives%2Ftechnology%2F2017%2F07%2F29%2FELK-Elasticsearch-core-structure-004.html</url>
    <content type="text"><![CDATA[擴容對應用程序的透明性 垂直擴容與水平擴容 保持負載均衡 Master node 節點對等，每個節點都能接收所有請求 Shard &amp; Replica One index includes one shard or more shard. When we create index, we set 3(ex) primary shard, then ES cluster can be balance for every shard. Every shard is a minimum working unit, which is a lucene instance. Every document is in the one primary shard and its replica shard. We cannot edit the number of primary shard , but can edit the number of replica shard. The same primary shard and replica shard cannot be in the same node. Create index Under the single node1234567PUT /test_index&#123; "settings" : &#123; "number_of_shards" : 3, "number_of_replicas" : 1 // Every primary shard has one replica shard. &#125;&#125; Under the two nodes Primary shard(node 1) data copy to replica shard(node 2). 横向擴容 （1）primary&amp;replica自动负载均衡，6个shard，3 primary，3 replica（2）每个node有更少的shard，IO/CPU/Memory资源给每个shard分配更多，每个shard性能更好（3）扩容的极限，6个shard（3 primary，3 replica），最多扩容到6台机器，每个shard可以占用单台服务器的所有资源，性能最好（4）超出扩容极限，动态修改replica数量，9个shard（3primary，6 replica），扩容到9台机器，比3台机器时，拥有3倍的读吞吐量（5）3台机器下，9个shard（3 primary，6 replica），资源更少，但是容错性更好，最多容纳2台机器宕机，6个shard只能容纳1台机器宕机 容錯 自動選舉一個node為新的master，承擔master的責任 新的master將丟失的primary shard的某個replica shard提升為primary shard Cluster status is yellow now. (P1,P2,P3 primary shard is active, but P1 miss one replica shard copy.) Restart downtime node. 新的master會將丟失的副本copy一份到此節點上，該node會使用之前已有的shard數據，只同步一下宕機之後發生的修改. Cluster status becomes green now.]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK_Kinds of search type_003]]></title>
    <url>%2Farchives%2Ftechnology%2F2017%2F07%2F29%2FKinds-of-search-type.html</url>
    <content type="text"><![CDATA[Basic Search Query string search Query DSL Query filter Full-test search Phrase search Highlight search Advance Search Group by Avg Sort Query string search 1GET /index/type/_search # all result Case one123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263GET /ecommerce/product/_search # all result------------------------------&#123; "took": 7, // used time(ms) "timed_out": false, // if it is check out "_shards": &#123; "total": 5, // 5 shard "successful": 5, // all request hits all primary shard &amp; replica shard "failed": 0 &#125;, "hits": &#123; "total": 3, // result "max_score": 1, // The meaning of the score is the match of a search for a search score, the more relevant, the more match, the score is also high "hits": [ // the details of result documents &#123; "_index": "ecommerce", "_type": "product", "_id": "2", "_score": 1, "_source": &#123; "name": "jiajieshi yagao", "desc": "youxiao fangzhu", "price": 25, "producer": "jiajieshi producer", "tags": [ "fangzhu" ] &#125; &#125;, &#123; "_index": "ecommerce", "_type": "product", "_id": "1", "_score": 1, "_source": &#123; "name": "jiaqiangban gaolujie yagao", "desc": "gaoxiao meibai", "price": 30, "producer": "gaolujie producer", "tags": [ "meibai", "fangzhu" ] &#125; &#125;, &#123; "_index": "ecommerce", "_type": "product", "_id": "3", "_score": 1, "_source": &#123; "name": "zhonghua yagao", "desc": "caoben zhiwu", "price": 40, "producer": "zhonghua producer", "tags": [ "qingxin" ] &#125; &#125; ] &#125;&#125; Case two paramter comes from http request. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172GET /ecommerce/product/_search?q=name:yagao&amp;sort=price:asc----------------------------------------------------------&#123; "took": 20, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "failed": 0 &#125;, "hits": &#123; "total": 3, "max_score": null, "hits": [ &#123; "_index": "ecommerce", "_type": "product", "_id": "2", "_score": null, "_source": &#123; "name": "jiajieshi yagao", "desc": "youxiao fangzhu", "price": 25, "producer": "jiajieshi producer", "tags": [ "fangzhu" ] &#125;, "sort": [ 25 ] &#125;, &#123; "_index": "ecommerce", "_type": "product", "_id": "1", "_score": null, "_source": &#123; "name": "jiaqiangban gaolujie yagao", "desc": "gaoxiao meibai", "price": 30, "producer": "gaolujie producer", "tags": [ "meibai", "fangzhu" ] &#125;, "sort": [ 30 ] &#125;, &#123; "_index": "ecommerce", "_type": "product", "_id": "3", "_score": null, "_source": &#123; "name": "zhonghua yagao", "desc": "caoben zhiwu", "price": 40, "producer": "zhonghua producer", "tags": [ "qingxin" ] &#125;, "sort": [ 40 ] &#125; ] &#125;&#125; Query DSL Query Domain Specified LanguageHttp request body: using JSON data structure 1234567891011121314151617181920212223GET /ecommerce/product/_search&#123; "query" : &#123; "match_all" : &#123;&#125; &#125;&#125;--------------------------------------------------------------GET /ecommerce/product/_search&#123; "query" : &#123; "match" : &#123; "name" : "yagao" &#125; &#125;, "sort" : [ &#123; "price" : "desc" &#125; ]&#125;--------------------------------------------------------------GET /ecommerce/product/_search&#123; "query" : &#123; "match_all" : &#123;&#125; &#125;, "from" : 1, // from 0 to total "size" : 2 // query result total&#125;--------------------------------------------------------------GET /ecommerce/product/_search&#123; "query" : &#123; "match_all" : &#123;&#125; &#125;, "_source" : [ "name" , "price" ]&#125; Query filter 123456789GET /ecommerce/product/_search&#123; "query" : &#123; "bool" : &#123; // include multiple query conditions "must" : &#123; "match" : &#123; "name" : "yagao" &#125; &#125;, "filter" : &#123; "range" : &#123; "price" : &#123; "gt" : 25 &#125; &#125; &#125; &#125; &#125;&#125; Full-text search Producer this field, which will be demolished to build an inverted index key item special 4 yagao 4 producer 1,2,3,4 gaolujie 1 zhognhua 3 jiajieshi 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081GET /ecommerce/product/_search&#123; "query" : &#123; "match" : &#123; "producer" : "yagao producer" &#125; &#125;&#125;--------------------------------------------------------------&#123; "took": 10, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "failed": 0 &#125;, "hits": &#123; "total": 4, "max_score": 0.70293105, // &lt;1&gt; "hits": [ &#123; "_index": "ecommerce", "_type": "product", "_id": "4", "_score": 0.70293105, // &lt;2&gt; "_source": &#123; "name": "special yagao", "desc": "special meibai", "price": 50, "producer": "special yagao producer", "tags": [ "meibai" ] &#125; &#125;, &#123; "_index": "ecommerce", "_type": "product", "_id": "1", "_score": 0.25811607, // &lt;3&gt; "_source": &#123; "name": "jiaqiangban gaolujie yagao", "desc": "gaoxiao meibai", "price": 30, "producer": "gaolujie producer", "tags": [ "meibai", "fangzhu" ] &#125; &#125;, &#123; "_index": "ecommerce", "_type": "product", "_id": "3", "_score": 0.25811607, // &lt;4&gt; "_source": &#123; "name": "zhonghua yagao", "desc": "caoben zhiwu", "price": 40, "producer": "zhonghua producer", "tags": [ "qingxin" ] &#125; &#125;, &#123; "_index": "ecommerce", "_type": "product", "_id": "2", "_score": 0.1805489, // &lt;5&gt; "_source": &#123; "name": "jiajieshi yagao", "desc": "youxiao fangzhu", "price": 25, "producer": "jiajieshi producer", "tags": [ "fangzhu" ] &#125; &#125; ] &#125;&#125; Partial update 123456POST /index/type/id/_update&#123; "doc" : &#123; "update_field" : "update field content" &#125;&#125; Partial update base on groovy script 1234POST test_index/test_type/11/_update&#123; "script": "ctx._source.num += 1"&#125; To add file test-add-tags.groovy is in the ES path/config/script/. 1234567891011121314POST /test_index/test_type/11/_update&#123; "script": &#123; "lang": "groovy", "file": "test-add-tags", "params": &#123; "new_tags": "tag1" &#125; &#125;&#125;-------------------------------------------1.ctx._source.tags += new_tags2.ctx.op = ctx._source.num == count ? 'delete' : 'none' If document is not exist, then execute to upsert initial operating If document is exist, then execute to groovy script operating. 12345678POST /test_index/test_type/11/_update&#123; "script" : "ctx._source.num+=1", "upsert": &#123; "num": 0, "tags": [] &#125;&#125; Phrase search (短语搜索) To input the query key, which will be demolished to build an inverted index 1234GET /ecommerce/product/_search&#123; "query" : &#123; "match_phrase" : &#123; "producer" : "yagao producer" &#125; &#125;&#125; Highlight search 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102GET /ecommerce/product/_search&#123; "query" : &#123; "match" : &#123; "producer" : "producer" &#125; &#125;, "highlight": &#123; "fields" : &#123; "producer" : &#123;&#125; &#125; &#125;&#125;--------------------------------------------------------------&#123; "took": 41, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "failed": 0 &#125;, "hits": &#123; "total": 4, "max_score": 0.25811607, "hits": [ &#123; "_index": "ecommerce", "_type": "product", "_id": "1", "_score": 0.25811607, "_source": &#123; "name": "jiaqiangban gaolujie yagao", "desc": "gaoxiao meibai", "price": 30, "producer": "gaolujie producer", "tags": [ "meibai", "fangzhu" ] &#125;, "highlight": &#123; "producer": [ "gaolujie &lt;em&gt;producer&lt;/em&gt;" ] &#125; &#125;, &#123; "_index": "ecommerce", "_type": "product", "_id": "3", "_score": 0.25811607, "_source": &#123; "name": "zhonghua yagao", "desc": "caoben zhiwu", "price": 40, "producer": "zhonghua producer", "tags": [ "qingxin" ] &#125;, "highlight": &#123; "producer": [ "zhonghua &lt;em&gt;producer&lt;/em&gt;" ] &#125; &#125;, &#123; "_index": "ecommerce", "_type": "product", "_id": "2", "_score": 0.1805489, "_source": &#123; "name": "jiajieshi yagao", "desc": "youxiao fangzhu", "price": 25, "producer": "jiajieshi producer", "tags": [ "fangzhu" ] &#125;, "highlight": &#123; "producer": [ "jiajieshi &lt;em&gt;producer&lt;/em&gt;" ] &#125; &#125;, &#123; "_index": "ecommerce", "_type": "product", "_id": "4", "_score": 0.14638957, "_source": &#123; "name": "special yagao", "desc": "special meibai", "price": 50, "producer": "special yagao producer", "tags": [ "meibai" ] &#125;, "highlight": &#123; "producer": [ "special yagao &lt;em&gt;producer&lt;/em&gt;" ] &#125; &#125; ] &#125;&#125; Aggs Case 1.1234567891011121314151617181920212223242526GET /ecommerce/product/_search&#123; "size" : 0, "aggs" : &#123; "group_by_tags" : &#123; "terms" : &#123; "field" : "tags" &#125; &#125; &#125;&#125;--------------------------------------------------------------&#123;..."buckets": [ &#123; "key": "fangzhu", "doc_count": 2 &#125;, &#123; "key": "meibai", "doc_count": 2 &#125;, &#123; "key": "qingxin", "doc_count": 1 &#125; ]...&#125; Case 2.1234567891011121314151617181920212223242526272829303132333435363738GET /ecommerce/product/_search&#123; "size" : 0, "aggs" : &#123; "group_by_tags" : &#123; "terms" : &#123; "field" : "tags" , "order" : &#123; "avg_price" : "desc" &#125; &#125;, "aggs" : &#123; "avg_price" : &#123; "avg" : &#123; "field" : "price" &#125; &#125; &#125; &#125; &#125;&#125;--------------------------------------------------------------&#123;..."buckets": [ &#123; "key": "fangzhu", "doc_count": 2, "avg_price": &#123; "value": 27.5 &#125; &#125;, &#123; "key": "meibai", "doc_count": 2, "avg_price": &#123; "value": 40 &#125; &#125;, &#123; "key": "qingxin", "doc_count": 1, "avg_price": &#123; "value": 40 &#125; &#125; ]...&#125; Case 3.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108GET /ecommerce/product/_search&#123; "size" : 0, "aggs" : &#123; "group_by_price" : &#123; "range" : &#123; "field" : "price", "ranges" : [ &#123; "from" : 0, "to" : 20 &#125;, &#123; "from" : 20, "to" : 40 &#125;, &#123; "from" : 40, "to" : 60 &#125; ] &#125;, "aggs" : &#123; "group_by_tags" : &#123; "terms" : &#123; "field" : "tags" &#125;, "aggs" : &#123; "avg_price" : &#123; "avg" : &#123; "field" : "price" &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;--------------------------------------------------------------&#123; "took": 8, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "failed": 0 &#125;, "hits": &#123; "total": 4, "max_score": 0, "hits": [] &#125;, "aggregations": &#123; "group_by_price": &#123; "buckets": [ &#123; "key": "0.0-20.0", "from": 0, "to": 20, "doc_count": 0, "group_by_tags": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [] &#125; &#125;, &#123; "key": "20.0-40.0", "from": 20, "to": 40, "doc_count": 2, "group_by_tags": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "fangzhu", "doc_count": 2, "avg_price": &#123; "value": 27.5 &#125; &#125;, &#123; "key": "meibai", "doc_count": 1, "avg_price": &#123; "value": 30 &#125; &#125; ] &#125; &#125;, &#123; "key": "40.0-60.0", "from": 40, "to": 60, "doc_count": 2, "group_by_tags": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "meibai", "doc_count": 1, "avg_price": &#123; "value": 50 &#125; &#125;, &#123; "key": "qingxin", "doc_count": 1, "avg_price": &#123; "value": 40 &#125; &#125; ] &#125; &#125; ] &#125; &#125;&#125;]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK_install & startup Elasticsearch & 'CRUD'_002]]></title>
    <url>%2Farchives%2Ftechnology%2F2017%2F07%2F29%2Finstall-startup-Elasticsearch.html</url>
    <content type="text"><![CDATA[To introduce to install &amp; startup ElasticsearchTo introduce Document data structureTo introduce easy cluster managementTo study Elasticsearch ‘CRUD’ operation Install Elasticsearch Download &amp; Install &amp; Startup elasticsearch : Elasticsearch To check if the Elasticsearch startup success. 127.0.0.1:920012345678910111213&#123; "name" : "PFS_monitor_node-1", // Node name "cluster_name" : "PFS_monitor_cluster", // Cluster name "cluster_uuid" : "tBEEZhRUS0O3SmduwgYZVw", // Cluster uuid "version" : &#123; "number" : "5.2.0", // Elasticsearch version "build_hash" : "24e05b9", "build_date" : "2017-01-24T19:52:35.800Z", "build_snapshot" : false, "lucene_version" : "6.4.0" // Lucene versoin &#125;, "tagline" : "You Know, for Search"&#125; Download &amp; Install Kibana : Kibana To use kibana to study Elasticsearch. Kibana dev tools 1234567891011121314151617&#123; "cluster_name": "PFS_monitor_cluster", "status": "yellow", "timed_out": false, "number_of_nodes": 1, "number_of_data_nodes": 1, "active_primary_shards": 1, "active_shards": 1, "relocating_shards": 0, "initializing_shards": 0, "unassigned_shards": 1, "delayed_unassigned_shards": 0, "number_of_pending_tasks": 0, "number_of_in_flight_fetch": 0, "task_max_waiting_in_queue_millis": 0, "active_shards_percent_as_number": 50&#125; Document Data Structure Java Data Structure Database structure table column t_employee ee_id int email varchar first_name varchar last_name varchar info_id int join_date datetime table column t_employee_info info_id int bio varchar age int interests varchar(100) Document data structureThe document data structure of elasticsearch is JSON 基於文檔的數據結構123456789101112131415&#123; email : myhongkongzhen@gmail.com, first_name : Jane, last_name : Wu, info : &#123; bio : curious and modest, age : 31, interest : [ film, takarazuka, eatting ] join_date : Jul 29th 2017 &#125;&#125; Elasticsearch cluster management ES health check(GET _cat/health?v) One of the ES apis : _cat ES health status green Every primary shard &amp; replica shard of index is active. yellow Every primary shard of index is active. Part of replica shard of index is not available. red Part of primary shard of index is not available. Data of part of index is lost. Check index of clusterGET _cat/indices?v12health status index uuid pri rep docs.count docs.deleted store.size pri.store.sizeyellow open .kibana SCPH1iHxTwiV6naHOTRiig 1 1 1 0 3.1kb 3.1kb Create indexPUT /zzwu_index?pretty12345678&#123; "acknowledged": true, "shards_acknowledged": true&#125;health status index uuid pri rep docs.count docs.deleted store.size pri.store.sizeyellow open .kibana SCPH1iHxTwiV6naHOTRiig 1 1 1 0 3.1kb 3.1kbyellow open zzwu_index AdEOBWZbTvawswsr8jgA-A 5 1 0 0 650b 650b Delete indexDELETE /zzwu_index?pretty12345678910111213141516171819202122232425&#123; "acknowledged": true&#125;&#123; "error" : &#123; "root_cause" : [ &#123; "type" : "index_not_found_exception", "reason" : "no such index", "resource.type" : "index_or_alias", "resource.id" : "zzwu_index", "index_uuid" : "_na_", "index" : "zzwu_index" &#125; ], "type" : "index_not_found_exception", "reason" : "no such index", "resource.type" : "index_or_alias", "resource.id" : "zzwu_index", "index_uuid" : "_na_", "index" : "zzwu_index" &#125;, "status" : 404&#125; Show Case Create index &amp; type1234PUT /index/type/id&#123; "json data"&#125; 12345678PUT /ecommerce/product/1&#123; "name" : "gaolujie yagao", "desc" : "gaoxiao meibai", "price" : 30, "producer" : "gaolujie producer", "tags": [ "meibai", "fangzhu" ]&#125; Search document1GET /index/type/id 1GET /ecommerce/product/2 Edit document replace 12345678PUT /ecommerce/product/1&#123; "name" : "jiaqiangban gaolujie yagao", "desc" : "gaoxiao meibai", "price" : 30, "producer" : "gaolujie producer", "tags": [ "meibai", "fangzhu" ]&#125; 1234PUT /ecommerce/product/1&#123; "name" : "jiaqiangban gaolujie yagao"&#125; update 123456POST /ecommerce/product/1/_update&#123; "doc": &#123; "name": "jiaqiangban gaolujie yagao" &#125;&#125; Delete document123456789101112131415DELETE /ecommerce/product/1----------------------------&#123; "found": true, "_index": "ecommerce", "_type": "product", "_id": "1", "_version": 10, "result": "deleted", "_shards": &#123; "total": 2, "successful": 1, "failed": 0 &#125;&#125;]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK_白話Elasticsearch_001]]></title>
    <url>%2Farchives%2Ftechnology%2F2017%2F07%2F23%2FELK-%E7%99%BD%E8%A9%B1Elasticsearch-001.html</url>
    <content type="text"><![CDATA[Elasticsearch分佈式、高性能、高可用、可伸縮的搜索和分析系統 搜索 垂直搜索 (站內搜索) 互聯網搜索 電商網站、招聘網站、新聞網站、各種APP IT系統的搜索 OA軟件、辦公自動化、會議管理、日程管理…… 搜索就是任何場景下，找尋你想要的信息，輸入一段關鍵字，期望找到這個關鍵字相關的信息 如果用數據庫進行搜索 電商系統SELECT * FROM products WHERE product_name like '%牙膏%' prod_id prod_name prod_desc prod_img 1 中華牙膏 2 中牙刷膏 3 雲南白藥牙膏 4 佳潔士牙膏 全表掃描,性能會很差 不能將關鍵字拆分開來，搜索更多符合期望的結果，搜索不到 中牙刷膏 查詢關鍵字可能很長很長…… 全文檢索和Lucene 1、檢索 (倒排索引) 全文檢索結構化搜索數據分析 1 生化 危機 電影 2 生化 危機 海報 3 生化 危機 文章 4 生化 危機 新聞 key ids 生化 1,2,3,4 危機 1,2,3,4 電影 1 海報 2 文章 3 新聞 4 什麼是全文檢索 倒排索引Wiki 2、What’s Lucene ? 簡單來說，Lucene就是一個jar包，包含了封裝好的各種建立倒排索引，以及進行搜索的代碼，包括各種算法。用java開發的時候，引入該jar包，基於路測呢滴api進行開發。 利用Lucene給已有的數據建立索引，Lucene會在本地磁盤上，組織索引的數據結構，還可以利用Lucene提供的API來針對磁盤上的索引數據，進行搜索。 3、What’s Elasticsearch ?High performance High availability Distributed Lucene is deployed on single server. When we save the big data, there is not enough space on single server. When we deploy lucene on more than one sever, we search the data, how do we communicate with multiple machines? When one lucene server is downtime, we need how to save the data on this server? Elasticsearch package underlying lucene. Elasticsearch core idea Near Realtime (NRT) : delay about 1s Cluster : include several Nodes Node : to be join default Cluster Document : the minimum unit of ES, include several fields Index : include several Types / Documents Type : logical classification Shard : Lucene Index, primary shard (易於橫向擴展) Replica : Copy of Shard, replica shard There are 10 default shard in one Index, 5 primary shard and 5 replica shard. Note: Replica shard and Primary shard cannot be on the same server. ES DB Field Column Document Row Type Table Index Database]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英文初級文法 Unit04 代名詞 — 001]]></title>
    <url>%2Farchives%2F%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95%2F2016%2F11%2F07%2F201611072216-English01-Unit04-%E4%BB%A3%E5%90%8D%E8%A9%9E-001.html</url>
    <content type="text"><![CDATA[代名詞：代替名詞 &lt;&lt;&lt;=== 不喜歡重複格 ： 即為表現 人稱代名詞 人稱代名詞的’人稱’及’格’人稱 \ 格 | 主格 | 所有格 | 受格 | 主格 | 所有格 | 受格 |第一人稱 | I | my | me | we | our | us |第二人稱 | you | your | you | you | your | you |第三人稱 | he | his | him | they | their | them |他 / 她 | she | her | her |它 | it | its | it |]]></content>
      <categories>
        <category>英文文法</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux權限 — 001]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2016%2F10%2F26%2F201610262247-Linux-Linux%E6%AC%8A%E9%99%90-001.html</url>
    <content type="text"><![CDATA[計算資源 權限 ==&gt; 定義了資源或服務的訪問能力 用戶 ==&gt; 定義某個用戶 ==&gt; 標示符 用戶組 ==&gt; 定義一類用戶，方便指定權限 ==&gt; 標示符 用戶、用戶組(權限的容器,邏輯概念)，關聯權限 進程是用戶操作計算機的代理 計算機資源三類用戶使用能力 文件的屬主(u) ==&gt; 文件的所有者 文件的屬組(g) ==&gt; 元生組 其他用戶(o) ==&gt; 既不是屬主也不屬於屬組 用戶 ==&gt; 獲取資源或服務的憑證 進程 ==&gt; 也擁有屬主和屬組 誰發起的進程，就以誰的身份操作(代理誰) 進程的發起者與文件的屬主相同，則可以訪問該文件 進程的安全上下文 權限 文件權限 r : readable ==&gt; 可以使用文件察看命令(比如: cat)察看文件 w : writeable ==&gt; 可以編輯或刪除文件 x : exacutable ==&gt; 可以在命令提示符下提交給内核運行 默認情況下，不應該讓文件有可執行權限 目錄權限 r : readable ==&gt; 可以對此目錄可以執行ls命令列出内部的所有文件 w : writeable ==&gt; 可以在此目錄中創建文件 x : exacutable ==&gt; 可以使用cd切換至目錄，也可以使用ls命令查看内部文件 默認情況下，應該讓目錄擁有可執行權限 權限變化組合 三位一體 二進制 十進制 -– 000 0 --x 001 1 -w- 010 2 -wx 011 3 \r– 100 4 \r-x 101 5 \rw- 110 6 \rwx 111 7 安全上下文 進程訪問文件，依賴於進程發起者的權限 發起者是否擁有該文件的訪問權限 /etc/passwd ==&gt; 定義系統中每個用戶信息 字段意義 account:passwd(一般為空或者星號，加密密碼在shadow中存儲):uid:gid:user-comments(一般為空,用戶的注釋信息):user-home:user-shell /etc/shadow ==&gt; 影子文件，用戶的密碼文件 字段意義 account:encrypted-passwd:date1:date2:date3:date4:date5:date6:reservedField encrypted passwd ==&gt; 8bit\$* \$1\$\$**(8bit長度)\$** 固定長度：標識，特殊意義(防止密碼相同，加密結果相同，被破解) 1 : md5加密方式 !! or * 賬戶被鎖定，不能登錄 date1 : 從19700101開始到密碼最近一次修改密碼的時間所經歷的時間 |(19700101)__|(last change pw)__|(current date) date2 : 密碼最短使用期限 date3 : 密碼最長使用期限 date4 : 警告時間，密碼離過期還有多長時間，開始提示用戶更改密碼 date5 : 密碼過期之後與用戶禁用之前之間時間，此間用戶登錄，只能改密碼，其他不能操作 date6 : 明確定義從19700101開始到哪一天為止，賬號禁用，賬號有效期 99999 永不過期 reserved field : 保留字段，暫無意義 /etc/group ==&gt; 定義系統中每個組信息 gname:psswd:gid:以此組為附加組的用戶列表,用逗號隔開，沒有為空 /etc/gshadow ==&gt; 組的密碼文件 加密方法 對稱加密：加密和解密使用同一個密碼 速度比公鑰加密快3倍以上 公鑰加密：每個密碼都稱對出現，一個私鑰(secret key),一個公鑰(public key) 加密字段長度比對稱加密長 單向加密：散列加密；用來提取數據特徵碼,每個數據的特徵碼都是唯一的 不可逆，單方向執行 也稱爲指紋加密, 可用于數據校驗 兩大特性 雪崩效應 定長輸出 MD5 : Message Digest, 128bit SHA1 : Secure Hash Algoritm, 160bit(更安全,更慢) 用戶類別 管理員 UID = 0 普通用戶 UID = 1 ~ 65535 系統用戶 ==&gt; 專門用來執行後臺程序的用戶，又不需要管理員權限，並且不需要登陸系統的用戶 UID = 1 ~ 499 一般用戶 UID = 500 ~ 60000(大約) 用戶相關權限默認值設置 cd /etc/default | file useradd 12345678# useradd defaults fileGROUP=100 # HOME=/homeINACTIVE=-1 # 密碼過期，用戶未禁用之間的期限 EXPIRE= # 非活動期限SHELL=/bin/bashSKEL=/etc/skelCREATE_MAIL_SPOOL=yes 用戶組類別 第一种分類 管理員組 普通用戶組 系統用戶組 一般用戶組 第二种分類 (較常用) 私有組 ==&gt; 創建用戶時，如果沒有指定用戶組，會同時創建一個同名的僅包含該用戶的私有組 基本組 ==&gt; 用戶的默認組 附加組、額外組 ==&gt; 默認組以外的其他組 權限管理命令 useradd or adduser ls -l which useradd ls -l \$(which adduser) useradd tom /etc/passwd /etc/shadow /etc/group passwd /etc/shadow passwd tom 密碼位 : !! ==&gt; 加密密碼 groupadd groupadd mygroup userdel usermod chsh chfn finger id change groupdel groupmod gpasswd chown chgrp chmod umask TODO]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell知識 — 001]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2016%2F10%2F25%2F201610252005-Linux-Shell%E7%9F%A5%E8%AD%98-001.html</url>
    <content type="text"><![CDATA[shell: 外殼, 自身也是一個可執行程序，儅用戶登錄之後，打開的命令輸入的環境就是shell GUI: Gnome, KDE, Xface CLI: sh, csh, ksh, bash, tcsh, zsh Shell知識 進程是程序的副本 進程是程序執行的實例，有生命周期，這個過程由内核管理 在每個進程看來，當前主機上只存在内核和當前進程 用戶工作環境 bash 是支持用戶自我定義自由環境的 shell與子shell 父子shell之間的設定沒有一定的關聯關係 bash特性 命令歷史、補全 !(-)N 執行命令歷史中的(倒數)第N條命令 !! 執行剛剛執行過的命令 !XX 執行history中最近的一個指定字符串開頭的命令 !\$ 直接引用上個命令的最後一個參數值 \$ cat /etc/passwd ==&gt; 察看passwd文件 \$ vim !$ ==&gt; 用vim編輯/etc/passwd ESC , . ==&gt; 按下ESC，再按點. 執行上個命令 ALT + . ==&gt; 同上，但要同時按住ALT和點 TAB ==&gt; 補全命令，PATH環境變量設置中的命令:w 路徑補全: 在打頭路徑下搜索 管道、重定向 命令別名 alias 別名 在shell中定義的別名，其有效作用範圍僅在當前shell進程 alias clear=’cls’ ==&gt; 給clear起個別名cls \clear ==&gt; 定義別名后，想要使用原本的命令，加反斜綫 unalias 撤銷命令別名 unalias clear 命令行編輯 ctrl + a ==&gt; 快速跳到行首 ctrl + e ==&gt; 快速跳到行尾 ctrl + u ==&gt; 快速刪除光標至行首 ctrl + k ==&gt; 快速刪除光標至行尾 ctrl + l ==&gt; 快速清屏-&gt;clear 命令替換 $(COMMAND) or COMMAND-&gt;(反引號) 把命令中某個子命令替換為其執行結果的過程 echo “The current directory is pwd“ touch ./file-$(date +%F-%H-%M-%S).txt ==&gt; file-2016-10-25-21-34-25.txt bash中支持的引號 `` : 反引號 ==&gt; 命令替換 “” : 冒號 ==&gt; 弱引用：可以實現變量替換 ‘’ : 單引號 ==&gt; 強引用：不完全變量替換 命令行展開,文件名通配,通配符不能描述所有情況，証則表達式可以解決這個問題 * 匹配任意長度、任意字符 \? 匹配任意單個字符 匹配指定範圍内的任意單個字符 [0-9] 所有數字 [abc] 從abc中選擇一個 [a-z] 所有小寫字母 [A-Z] 所有大寫字母 [a-zA-Z] 所有英文字母 [^] 匹配指定範圍之外的任意字符 [^0-9] 非數字字符 [:alpha:]][[:space:]][^[:digit:]] [[ ]] ==&gt; 兩個中括號指定特殊字符 \$ man 7 glob ==&gt; 察看特殊字符表示 [[:space:]] 指定空白字符 [[:punct:]] 指定標點符號 [[:upper:]] 指定所有大寫字母 [[:alpha:]] 指定字母表，大小寫字母 [[:digit:]] 指定數字 [[:alnum:]] 指定數字和大小寫字母 變量 編程 …]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英文初級文法 Unit03 be動詞、一般動詞的過去式 — 001]]></title>
    <url>%2Farchives%2F%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95%2F2016%2F10%2F24%2F201610242224-English01-Unit03-be%E5%8B%95%E8%A9%9E-%E4%B8%80%E8%88%AC%E5%8B%95%E8%A9%9E%E9%81%8E%E5%8E%BB%E6%99%82-001.html</url>
    <content type="text"><![CDATA[時態：動詞會隨著時間而改變形態過去式: 已經發生過的狀態或者動作 be動詞的過去時 ==&gt; was / were am / is ==&gt; was | are ==&gt; were 過去時be動詞表示 ==&gt; 過去時間中發生的狀態 He is busy now.(現在式) He was busy then.(過去時)時間副詞改變，動詞也要隨之改變 My parents are at home now. My parents were at home yesterday. 我的父母昨天在家，表示今天不在家. be動詞過去式的否定句 ==&gt; 主詞 + was / were not + … Mr. Brown was a vet(獸醫). Mr. Brown was not a vet. 以前不是，現在是 Joe and Brian were in the living room at that time(==&gt;then). Joe and Brian were not in the living room at that time. be動詞過去式的疑問句 疑問句 ==&gt; Was / Were 主詞 + … ? Wendy was in the seventh grade last year. Was Wendy in the seventh grade last year? Wendy去年就讀7年級嗎? 答句 Yes, 主詞(代名詞) + was / were. No, 主詞(代名詞) + was / were. Were you a pianist?(==&gt;什麽樣的人) 你曾經是個鋼琴傢嗎? Yes, I was. / No, I weren’t. 一般動詞的過去時 一般動詞過去時的變化 規則變化 -ed [t] [d] [Id] 原形動詞 + ed helped [t] 無聲髮無聲 spelled [d] 有聲髮有聲 wanted [Id] needed [Id] 原形動詞字尾有e + d love -&gt; loved dance -&gt; danced 原形動詞為子音 + 短母音 ==&gt; 重復字尾 + ed stopped planned 原形動詞字尾為子音 + y ==&gt; 去y + ied study -&gt; studied cry -&gt; cried 擴展 現在式 : 去y + ies ==&gt; 第三人稱單數 形容詞 : 去y + ier ==&gt; 比較級 不規則動詞變化 eat -&gt; ate read -&gt; read ride -&gt; rode 實例 I walk to school every day. I walked to school yesterday. Mother goes to a supermarket every morning. Mother went to a supermarket yesterday morning. 一般動詞過去時的否定句 ==&gt; did(助動詞) not + 原形動詞 He called you last night. He did not(==&gt; didn’t) call you last night. My sister and I watched TV all day yesterday. My sister and I didn’t watch TV all day yesterday. 昨天我和我姐姐並非看了一整天的電視。(只看了一點點電視)not + all ==&gt; 並非全部 一般動詞過去時的疑問句 ==&gt; Did + 主詞 + 原形動詞 … ? His friends went to that movie last week. 他的朋友上星期去看了那部電影。 Did his friends go to that movie last week? Grace wrote a letter to David. Did Grace write a letter to David? 答句 Yes, he did. No, he didn’t.]]></content>
      <categories>
        <category>英文文法</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英文初級文法 Unit02 be動詞、一般動詞的現在式 — 001]]></title>
    <url>%2Farchives%2F%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95%2F2016%2F10%2F17%2F201610200735-English01-Unit02-be%E5%8B%95%E8%A9%9E-%E4%B8%80%E8%88%AC%E5%8B%95%E8%A9%9E%E7%8F%BE%E5%9C%A8%E5%BC%8F-001.html</url>
    <content type="text"><![CDATA[be動詞 ==&gt; 表示狀態、存在一般動詞 ==&gt; 表示動作 具體動作、抽象動作 看得見的動作（走路、吃飯、唱歌） 看不見的動作（了解、知道、愛）現在式 ==&gt; 時態、動作的形態會隨著時間改變文法名稱代表用法 be 動詞的現在式 ==&gt; am , is , are be 動詞的含義 是(狀態) We(s.) are(v.) happy. 在(存在) She is in America. S. + be 第一人稱（I）+ am ==&gt; I am a boy. 第二人稱（You/They）/複數名詞 + are ==&gt; You are my sons. 第三人稱（He/She）/單數名詞 + is ==&gt; He is my student. be 動詞的否定 ==&gt; am / are / is + not 肯定: 主詞 + am / are / is 否定: 主詞 + am / are / is + not He is a good baseball player. He is not a good baseball player. be 動詞的疑問句 =&gt; 將 be 動詞 提前 肯定句：主詞 + am / are / is … . 疑問句：Am / Are / Is + 主詞 … ? ( 嗎？) That is his camera. =&gt; Is that his camera ? The girl is a junior high(囯中生/senior高中生) school student. Is the girl a junior high school student ? be 動詞開頭的疑問句，可用Yes / No 回答。 Yes, S.(代名詞) + am / are / is. No, S.(代名詞) + am / are / is not. Is that man your math teacher ? Yes, he is. / No, he is not.(用代名詞回答) No, he’s my PE(體育老師) teacher. Are you eating your lunch ? Yes, I am. / No, I’m not. 一般動詞的現在式 主詞 + 一般動詞==&gt;現在式、主詞為第三人稱單數，一般動詞加 s或 es 第一人稱 : I like dogs. / We like dogs. 第二人稱 : You like dogs. / You like dogs. 第三人稱 : He likes dogs. / They like dogs. 一般動詞加 s或 es的方法 大部分動詞加s,其發音為[s]或[z] works [s] plays [z] 字尾為o, s, sh, ch時加es goes [z] washes [IZ] watches [IZ] 字尾為子音 + y時，去y + ies cry –&gt; cries study –&gt; studyies have ==&gt; (有、吃)單數動詞 —&gt; has They have a lot of money(不可數n.). He has a lot of money. 一般動詞的否定句 ==&gt; 不可以在一般動詞後面直接加NOT,必須用助動詞do/does do ==&gt; 用於主詞為I、you 或者複數 does ==&gt; 用於主詞為第三人稱單數 肯定句 : 主詞 + 一般動詞… 否定句 : 主詞 + do/does + not + 一般動詞原形… The twin brothers go to school by bus. The twin brothers do not go to school by bus. Sam has dinner at the restaurant. Sam does not have dinner at the restaurant. 比較 : 否定句 be 動詞 He is my boyfriend. He isn’t my boyfriend. 一般動詞 He likes dogs. He doesn’t like dogs. 一般動詞的疑問句 ==&gt; 不能把一般動詞放主詞前，要用助動詞do / does 疑問句 : Do / Does + 主詞 + 一般動詞原形… ? You visit(探訪) your grandmother on Sundays(每逢星期天). Do you visit your grandmother on Sundays? He comes from England. Does he come from England? 助動詞do / does開頭的問句、Yes / No回答之後用do / does 回答 Does the little boy go to school? Yes, he does. No, he doesn’t. 比較 : 疑問句 be動詞: She is beautiful. Is she beautiful? Yes, she is. 一般動詞: She loves tennis(網球). Does she love tennis? Yes, she does.]]></content>
      <categories>
        <category>英文文法</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基礎知識 — 002]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2016%2F10%2F17%2F201610172027-Linux-Linux%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98-002.html</url>
    <content type="text"><![CDATA[Linux的基本原則 由目的單一的小程序組成；組合小程序完成複雜人物； 一切皆文件； 盡量避免捕獲用戶接口； 配置文件保存為純文本格式。 基礎概念 文件系統 file system 層次化管理 FHS : Linux文件系統層級標準 /boot : 系統啓動相關的文件- 内核、initrd、grub(bootloader) initrd* : 操作系統啓動所用的内核 應用程序在硬盤上叫做程序，啓動起來之後叫做進程 進程啓動起來的外部，啓動起來各個共享庫 vmlinuz* /dev : devise 設備文件 /dev/cdrom 塊設備 : 隨機設備、可以實現隨機訪問 磁盤、硬盤 數據塊訪問 字符設備 : 綫性設備、按字符為單位訪問 顯示器、鼠標 /etc : 配置文件 /home : 主目錄 /home/USERNAME /root : root home /lib : 庫文件及内核模塊文件 被調用的一些封裝好的某些功能,不能單獨運行，沒有程序運行入口 /lib/modules : 内核模塊 靜態庫 .a 直接連接到程序地址空間中，作爲程序的一部分而運行的 動態庫 .dll(windows), .so(shared object) 只需將共享庫載入内存一份即可,節約内存空間 /media : 挂載點目錄 挂載 : 把某個設備與文件系統樹上的某個節點(目錄)關聯起來的過程 必須挂載才能使用 通常挂在移動設備 /mnt : 挂載點目錄 通常挂在額外的文件系統，如：第二塊硬盤 /misc : 雜項 /opt : 可選目錄 早期用於安裝第三方程序 /proc : 偽文件系統；内核影射文件 空目錄，但啓動后，顯示内核的映像文件 系統調優、系統監控有關 /sys : 偽文件系統；硬件設備相關屬性影像文件 系統調優、系統監控有關 /tmp : 臨時文件 通常每一個月清理一次 /var/tmp /var : 可變化的文件 /bin : 可執行文件, 用戶命令 /sbin : 管理命令 /usr : universal shared, read-only 全局共享只讀文件 /usr/bin /usr/sbin /usr/lib /usr/local : 第三方軟件 /usr/local/bin /usr/local/sbin /usr/local/lib /usr/local/etc Tree : 樹狀結構 絕對路徑 相對路徑 rootfs : 根文件系統 文件的節點 : index node , inode 環境變量 : 命名的内存空間 變量賦值 PATH : 冒號(:)分隔 ==&gt; 命令搜索路徑 HISTSIZE : 命令歷史緩衝區大小 命令格式 命令 選項 參數 短選項: - 多個選項可以組合： -a -b ==&gt; -ab 長選項: -- 多個選項不可以組合 magic number : 標誌程序的執行格式 shebang : #!/bin/bash 計算機時間 晶體震蕩器 ==&gt; 主板、鈕扣電池 ==&gt; 硬件時間、實時時鐘 rtc: realtime clock NTP : 網絡時間協議 Linux時間 硬件時鐘 系統時鐘 可執行文件的存儲格式 Linux : ELF Windows : PE ASCII : 美國國家標準信息交換代碼 純文本字符 word : 字處理器 128個不同字符，用二進制表示 2 ^ 6 = 0,63 = 64 2 ^ 7 = 0,127 = 128 000 0000 - 111 1111 GPL, BSD, Apache 自由軟件:開源協定，版權描述 www.kenel.org Linux僅僅是一個内核, 源代碼 GNU: GNU/Linux 常用命令 目錄管理 ls cd pwd mkdir rmdir tree 文件管理 touch stat file rm cp mv 時間管理 date clock hwclock cal su : switch user su [-l(完全切換)] username passwd : pass word 密碼複雜性 0 ~ 9 ==&gt; 10 ^ 6 (6位密碼)破解次數 0 ~ 9 + 26 lower char ==&gt; ( 10 + 26 ) ^ 6 login user : userId 認證機制 : Authenticatoin 授權 : Authorization 審計 : Audition ( LOG ) ls : list 目錄 : 文件、路徑影射 路徑 : 從指定起始點到目的地所經過的位置 -h : human readable 單位轉換 : B–&gt;K–&gt;M–&gt;G–&gt;T-&gt;… -a : all 顯示所有文件、包含以.(點)開頭的隱藏文件 -A : all 不包含.(點) &amp; ..(點點) -d : 顯示目錄自身屬性 -i : inode 顯示每個文件的索引節點號 -r : 逆序顯示文件(自然順序逆序) -R : recursive 遞歸現實 -l : long 長格式、顯示更多屬性 1- \-rw-r--r-- 1 43984076 1049089 21929 Oct 19 20:29 _viminfo -rwxr-rx-r : 10位 第一位 : 文件類型 - : 普通文件(f) d : 目錄文件 b : 塊設備文件(block) c : 字符設備文件(character) l : 符號鏈接文件(symbolic link file) p : 命令管道文件(pipe) s : 套接字文件(socket) 后九位 : 文件權限 每三位一組 x : 執行 r : 讀 w : 寫 1 : 文件被硬連接的次數 43984076 : owner 1049089 : group 21929 : file size (byte) 特殊文件不顯示文件大小，而顯示設備號:主設備號(major)和次設備號(minor) Oct 19 20:29 : timestamp ==&gt; 這裡顯示的是 –&gt; 最近一次被修改的時間 每個文件都有三個時間戳 最近一次被訪問的時間 access 最近一次被修改的時間 modify 文件的内容數據 最近一次被改變的時間 change 文件的屬性數據 : 元數據 metadata Ex : 修改文件名 _viminfo : 文件名 pwd : print working directory / : 斜綫 \ : Windows ==&gt; 反斜綫 cd : change directory home directory : 主目錄、家目錄 # cd ~student : 管理員去到student (指定用戶)用戶的家目錄 \$ cd - : 當前目錄與上一個目錄之間來回切換 type Linux命令類型 内置命令 : shell ==&gt; XX is a shell builtin. 外部命令 : 在文件系統的某個路徑下有與命令名稱相應的可執行文件 \$ type cd ==&gt; 顯示命令屬於哪种命令類型 cd is a shell builtin. hash : 緩存，將用過的命令緩存起來，避免每次到路徑中尋找執行命令 O(1) : 時間複雜度 date : 顯示系統時間 \$ date 1021195416.27 (默認格式：MMDDhhmmCCYY.ss) \$ date +%D \$ date +”Today is %Y-%M-%d.” \$ date +%s (UTC:格林尼治時間) clock : 顯示硬件時間 hwclock hwclock -w 將系統時間同步到硬件時間 hwclock -s 讀取硬件時間到系統時間 man : 獲取命令使用幫助 \$ man ls \$ man cd ==&gt; 内部命令、顯示的是對應的shell幫助 分章節 (常見章節8個) 用戶命令(/bin, /usr/bin, /usr/local/bin) 系統調用 庫調用 特殊文件(如：設備文件,設備的訪問入口存在，沒有存儲内容) 文件格式(解釋：配置文件的語法) 遊戲 雜項, Miscellaneous 管理命令(/sbin, /usr/sbin, /usr/local/sbin) \$ man 2 read ==&gt; 顯示第二章節的内容 help : 獲取内部命令的使用幫助 \$ help cd 或者使用 --help info : 在綫命令手冊，命令歷史 /usr/share/doc ==&gt;内核幫助文檔 whatis : 顯示命令摘要 \$ whatis read ==&gt; 顯示read命令在哪些章節中 cal : calendar 日曆 echo : 默認有換行符 echo -e “This is a dog.\nI like it.” -e 開啓轉義字符功能 print : 默認沒有換行符 printf “This is a dog.\n” mkdir mkdir -pv ./jwuzz/y ==&gt; 遞歸創建不存在的目錄,並顯示詳細信息 -v 詳細信息 mkdir -pv /home/jwuzz/{x,z} ==&gt; 同時創建x、y兩個目錄 ‘{ }’花括號展開 mkdir -pv /home/jwuzz/{a,b}_{c,d} /home/jwuzz/a_c /home/jwuzz/a_d /home/jwuzz/b_c /home/jwuzz/b_d tree : 察看目錄樹 rmdir : remove directory 只能用於刪除空目錄 touch : 本不是用來創建文件的，但卻可以創建文件 change file timestamps touch newfile touch -c newfile ==&gt;如果文件不存在，不創建 -a change only the access time -m change only the modification time -t CCYYMMddhhmm.ss ==&gt; 指定時間 stat 顯示文件或文件系統的狀態信息 stat filename File: ‘a’Size: 0 Blocks: 0 IO Block: 65536 regular empty fileDevice: 74e2337eh/1960981374d Inode: 24769797950777130 Links: 1Access: (0644/-rw-r–r–) Uid: (2826018/43984076) Gid: (1049089/ UNKNOWN)Access: 2016-10-21 22:21:19.408805800 +0800Modify: 2016-10-21 22:21:19.408805800 +0800Change: 2016-10-21 22:21:19.408805800 +0800 Birth: 2016-10-21 22:21:02.279975700 +0800 rm : remove rm -rfv * -i ==&gt; 交互式 -f ==&gt; 強制 -r ==&gt;遞歸刪除(目錄下的所有文件) alias \rm ==&gt; 使用rm自身命令，而不是使用別名后的命令 cp : copy 複製一個文件到一個文件 複製多個文件到一個目錄 cp /etc/passwd /tmp ==&gt; /tmp/passwd cp /etc/passwd /tmp/test ==&gt; /tmp/test -R(or -r) (遞默認不複製目)錄歸複製init.d下的所有文件及其子文件夾下的文件 -f force 強制複製 -i 目標存在，則提示是否覆蓋 -p preserve(保留)mode,ownership,timestamps -a archive、歸檔存放，用於備份，保留複製文件的所有屬性 -P(or -d) 複製文件如果為連接文件，則保存連接文件自有屬性 -L 複製文件如果是連接文件，則複製的是文件本身，而不是連接文件 mv : move -t cp -t DEST SRC (先指定目標、再指定源) install copy files and set attributes 創建、複製文件 -m 指定複製后的權限 不指定時，複製后的文件默認有x執行權限 -d 創建目錄，不能複製目錄 install -d /tmp/{a,b}/c ==&gt; 創建多個目錄/tmp/a/c,/tmp/b/c cat 察看文本文件 -n 顯示行號 (類似于vim的set nu) -E show ends顯示每行的結束符 Linux 行結束符是\$ Windows 行結束符為\$ tac 與cat相同，但從尾部向頭部顯示，逆序顯示 less 分屏察看，可向前向後 space / b / CR / k / /？(the same as ‘man’) more 分屏察看，只能向後 space / b / CR head 察看文件前N行，默認n = 10 -n N 指定顯示N行 tail 察看文件后N行，默認n = 10 -n N -f 監控日誌神器^_^ cut -d 指定分隔符 -f 顯示第幾個字段 -f 1 ,3 顯示第一個 和第三個字段 -f 1 -3 顯示第一個 到第三個字段 join 文本拼接,不常用 sort 文本排序 默認字符自然順序升序排序 -n 按數值排序 -r 逆序排序 -t 指定分隔符、按照指定字段排序 -k 指定字段 \$ sort protocols -t’ ‘ -k2 -n -u 只顯示唯一一個，去重復 -f 忽略字符大小寫 uniq 報告或略過重復的行 如果重復的行不相鄰，則linux不認爲是重復的行 -d 只顯示重復的行(1) -D 顯示重復的行(2) -c count重復的行 wc word count 19 18 113 ddd 行 單詞 字節 -l 行(19) -c or -m 字節(113) -w 單詞(18) -L 最長的一行包含的字符 tr translate or delete char 轉換或刪除,逐個字符處理 tr ab AB ==&gt; 將小寫ab換成大寫AB, 字符一一對應，而不是AB當作整體替換 tr ab AB &lt; /etc/passwd ==&gt; 利用輸入重定向將文件中的小寫ab換成大寫AB tr ‘a-z’ ‘A-Z’ ==&gt; 範圍替換 -d 刪除字符集中出現的所有字符 history 命令歷史 -c clear history -d 刪除指定位置的history history -d 500 10 ==&gt; 刪除從500開始的10個history -w 將緩衝區的history保存到歷史文件中 clear 清屏 TODO …]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英文初級文法 Unit01 名詞、冠詞 — 001]]></title>
    <url>%2Farchives%2F%E8%8B%B1%E6%96%87%E6%96%87%E6%B3%95%2F2016%2F10%2F09%2F201610092003-English01-Unit01-%E5%90%8D%E8%A9%9E-%E5%86%A0%E8%A9%9E-001.html</url>
    <content type="text"><![CDATA[名詞的功用：當 主詞、 補語、 受詞什麽是名詞： 人、 事情、 地點、 物品 的名稱名詞有 單數、 複數 之分;有單複數的名詞在句子中要將單複數表現出來 一、名詞的種類 普通名詞 book. pencil. dog. spaceship… 集合名詞 class. family. audience(觀衆)… My family is large. 我的家庭是個大家庭，集合名詞，單數名詞。 My family are all early risers(複數). 我的家人都起得很早。I like dogs 我喜歡狗。我喜歡的是狗狗這一類的動物，而不是這只狗狗或那只狗狗。是一種類型 專有名詞 Bob. Smith. April. London… 專有名詞沒有單複數的表現，但有些專有名詞需要加定冠詞The the United States. the United Nations. 物質名詞 glass. wood. paper. fruit. butter… 數字 + 容器（度量衡）+ of + 物質名詞 單複數表現形式:度量衡 a loaf of bread a cup of coffee a sheet of paper a spoonful of sugar a handful of sugar 一把糖果 an armful of mood 一把木材 抽象名詞 beauty. love. patience. honesty. happiness. music… 不可數名詞 二、名詞的數：單數、複數 規則變化的複數…~S 名詞字尾加 s -&gt; 大部分名詞 dog -&gt; dogs _[gz] 有聲發音 book -&gt; books [ks] 無聲發音 名詞字尾為 s、sh、ch、x、o -&gt; 加es class -&gt; classes [IZ] bus -&gt; buses [IZ] dish -&gt; dishes [IZ] bench -&gt; benches [IZ] box -&gt; boxes [IZ]詞尾為子音+O，複數名詞加es：tomatoes. 例外：photos. pianos… 名詞字尾為子音+ y -&gt; 去掉 y + ies baby -&gt; babies [IZ] story -&gt; stories [IZ] city -&gt; cities [IZ] lady -&gt; ladies [IZ] 名詞字尾為 f 或 fe -&gt; 去掉 f 或 fe + ves leaf -&gt; leaves wife -&gt; wives knife -&gt; knives例外：handkerchiefs. chiefs. roofs. 不規則變化的複數名詞 ox -&gt; oxen / child -&gt; children / man -&gt; men / woman -&gt; women goose -&gt; geese / tooth -&gt; teeth / mouse -&gt; mice 單複數同行 fish / deer / sheep / Chinese / Japanese 三、名詞的所有格 (格：一種表現) 形成 單數名詞 -&gt; 名詞’s the boy’s schoolbag Joan’s dress 複數名詞 -&gt; 名詞s’ a girls’ school 一所女校 these students’ teacher 這些學生的老師 字尾非ｓ的複數名詞 -&gt; 名詞’s children’s playground 小盆友們的遊樂園 women’s activities 女士們的活動 特別注意的所有格用法 共同所有格及個別所有格 共同所有格 -&gt; 名詞+名詞+名詞+…+名詞’s Harry and Bill’s father is a scientist. 個別所有格 -&gt; 名詞’s+名詞’s+名詞’s+…+名詞’s Harry’s and Bill’s father are scientists. (無)生物所有格: A 的 B -&gt; B of A the legs of the table the doors of the car the girl’s name &lt;==&gt; the name of the girl 可以省略所有格之後的名詞的情況 She’s going to the dentist’s. I met him at the basket’s. We like to eat lunch at McDonald’s. 四、冠詞：修飾名詞 不定冠詞： a / an 數量唯一，沒有限定，可數名詞的單數 a -&gt; 子音開頭的單數名詞 a book a girl an -&gt; 母音開頭的單數名詞 an apple an umbrella an old woman I read a novel. I read a novel, not two. 定冠詞： the 代表限定：這個、那個、這些、那些，特定的某一個(單數)或特定的某一些(複數) Please shut the door.請關門、講話人一定會指著是哪一扇門，限定了門。 講話者和聽話者都知道的情況下，一定要加上定冠詞the The rich aren’t always happy.有錢人並非總是快樂的。 the + 形容詞泛指“…的人”，代表複數 比較 | 不定冠詞( a Ban ) | 定冠詞( The ) | | ————— | ————– | | 表示不特定之事物 | 表示特定之事物 | | 只能接可數名詞 | 可接可數名詞及不可數名詞 | | 只能接單數 | 可用於單數和複數 |]]></content>
      <categories>
        <category>英文文法</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基礎知識 — 001]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2016%2F10%2F04%2F201610041954-Linux-Linux%E5%9F%BA%E7%A4%8E%E7%9F%A5%E8%AD%98-001.html</url>
    <content type="text"><![CDATA[Linux基礎知識，在虛擬機下學習，安裝RedHat5 Server斷斷續續學習Linux，總也不得要領，好在對Linux的字符界面情有獨鐘，還是繼續學習下去吧^_^ :bowtie: Vmware 安裝linux: 通過網絡引導槃安裝Linux及幾處要點 虛擬機安裝linux后，想要利用宿主機器連接網絡，需要配置虛擬網絡，配置方法多種，這裡選擇使用 僑接 方式配置 製作快照 通過命令安裝Ｌｉｎｕｘ 1linux ip=172.168.1.22 netmask=255.255.255.0 gateway=127.0.0.1 dns=172.16.0.1 ks=http://172.16.0.1/class.cfg 計算機基礎知識 計算機啓動過程：POST (power on and self testing) 加電自檢 計算機只是一堆硬件,CPU加載到指令才行執行 開機之前，指令在何處存儲？ 光盤、硬盤、移動設備等 Boot調整加載順序 計算機自擧能力 : BIOS ROM : 將此中的指令，映射到内存中，硬件芯片邏輯完成 程序：指令 + 數據 載入内存才行執行 計算機體系結構(馮諾依曼體系結構) 運算器 -&gt; 加法運算器、邏輯運算器 負責運算 寄存器：與CPU相同頻率工作 控制器 -&gt; (與運算器合稱 CPU) 負責控制運算器到哪取數據進行運算 接受控制指令：控制總綫 存儲器 -&gt; RAM.内存，易失性設備，編址存儲設備(8bit), 平面編址 負責存儲數據、指令運算器從存儲器中拿到數據進行運算，並且把運算的結果還放到存儲器中 從存儲器的什麽地方讀 運算完成后，數據放到存儲器中的什麽位置上去 保存磁信號、轉換成電信號 輸入設備 輸出設備 硬件平臺架構 CPU芯片的不同系列 程序是需要移植的 ARM X86 (Intel or AMD) 安籐 alpha UltrSparc Power M68000/M68K PowerPC OS Windows Linux Unix HP-UX Solaris AIX SCO UNIX Unixware OS/2 MainFrame：大型機 Multics：多任務、多功能 基本概念 中斷：interrupt -&gt; 硬件通知機制 外圍設備通過中斷同CPU交互 –&gt; 中斷越少越好，CPU性能越高 可編程中斷控制器：針腳與CPU相連 中斷向量 -&gt; 標示不同設備 前端總綫：FSB 北喬設備：離CPU較近，連接南橋及其他總綫控制 CPU與内存交互、之間有總綫相連，並且需要有控制器 高速總綫控制器 南橋設備：離CPU較遠，連接外圍設備 低速總綫控制器 主頻：赫茲／頻率 -&gt; 一次頻率，完成一次數據事件 緩存：一級緩存(小，快，造價高，CPU近)、二級緩存… 決定CPU性能 指令緩存 數據緩存CPU -&gt; 寄存器 -&gt; 一級緩存 -&gt; 二級緩存 -&gt; 内存 要緩存的數據，遵循程序的局部性原理 時間上局部性：上次載入的數據，很快會被再次利用 空間上局部性：載入一個數據，將附近的數據一同載入 程序的移植：底層芯片的不同 低級語言 機器語言：二進制編程 微碼：彙編語言(人類容易識別) -&gt; 編譯器 仍然與底層芯片緊密關聯 高級語言 轉換成彙編語言、再翻譯成機器語言 -&gt; 編譯器 批處理系統：現代操作系統前身 1jobs1$$$$$jobs2$$$$$ Job：運行的一次完整的計算過程.批處理作業 多任務 CPU/Memory 切割 時間驅動：slice 時間片 分段機制：相對地址 虛擬地址空間 操作系統(kernel,内核)：管理硬件資源 -&gt; 負責切割、切換、協調等工作 system call API 保存程序現場，從結束的地方繼續 進程 庫：一堆的程序，高級的接口 API 沒有執行入口，只提供調用接口、被調用執行 call Shell：人機交互接口 GUI : 圖形界面 GLI : 命令行界面 IDE : Intergratent Devlopt Enverment DLL : Dynamic Link Library ==&gt; Windows .so : shared object ==&gt; Linux CPU四級別：四個同心圓環 、應用程序與内核隔離 最内層：0級別、特權級、内核運行 最外層：其他應用程序 中間兩層未用 内存碎片 ABI: Application Binary Interface 内核的功能 通用軟件 進程管理 内存管理 文件系統 網絡功能 硬件驅動 安全機制 Unix 系列分支 FreeBSD OpenBSD NetBSD … GNU: GNU IS NOT UNIX. Stallman -&gt; Freedom GPL: General Public License Emacs: 文本編輯器 gcc: GNU C Complier bash: shell … LGPL: Lesser GPLv2 GPLv3 維護軟件 Linux : Linus維護内核 Apache BSD Linux: 發行版 release、編譯成二進制后可運行的系統 Redhat (RPM、軟件包管理軟件) CentOS Fedora Mandriva Debian (DPT、軟件包管理軟件) Ubuntu Mint (界面華麗) SLS SUSE -&gt; Novell(Netware) Open SUSE …]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown流程圖簡明語法規則]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2016%2F09%2F16%2F201609161830-Markdown%E6%B5%81%E7%A8%8B%E5%9C%96%E7%B0%A1%E6%98%8E%E8%AA%9E%E6%B3%95%E8%A6%8F%E5%89%87.html</url>
    <content type="text"><![CDATA[爲了方便再現編輯MARKDOWN文件，重新學習一下markdown語法知識，基礎的大部分都已掌握，但對於高級用法，比如甘特圖等，還未掌握到要點，這裡記錄一下可行的語法結構。更悲催的是github.io上畫不出來流程圖，也許是沒有寫對github的markdown語法，再問問狗哥~~~ Mardown流程圖語法實現關鍵字、基本類型 start end operation subroutine condition inputoutput 畫圖標識```flow語法規則``` Example1234567891011121314st=&gt;start: 開始:&gt;http://google.come=&gt;end: 結束:&gt;http://www.baidu.comop1=&gt;operation: 我的操作op2=&gt;operation: 暫停sub=&gt;subroutine: 我的子操作con1=&gt;condition: 是 or 否:&gt;http:www.google.comcon2=&gt;condition: Good ideaio=&gt;inputoutput: catch something...st-&gt;op1-&gt;con1con1(yes)-&gt;con2con1(no)-&gt;sub-&gt;op1con2(yes)-&gt;io-&gt;econ2(no)-&gt;op2-&gt;e 流程圖比較複雜，用markdown畫出比較酷玄的流程圖，還是比較麻煩的，而且跟各個平臺有關，github的markdown與什麽大象筆記的markdown語法就不相同，所以，簡單劃一畫，複雜的，還是截圖比較方便ww。]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[並發包J.U.C相關--原子類]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2016%2F04%2F12%2F201604121223-%E4%B8%A6%E7%99%BC%E5%8C%85J-U-C%E7%9B%B8%E9%97%9C-%E5%8E%9F%E5%AD%90%E9%A1%9E.html</url>
    <content type="text"><![CDATA[最近博客更新的少，不是沒有學習，只是最近都在用手寫筆記，其實自己比起使用電腦等電子產品記錄筆記，還是更加喜歡手寫筆記，一來本身就喜歡寫字，當然字也沒有太好看ww，二來，手寫筆記記憶會比較深刻，三嘛，就是懶了…一懶了，就不願意敲鍵盤了，當然，敲代碼和敲鍵盤打字，可不是同一個概念，所以這裡的懶，就只針對於打字www，不過還是要時常敲敲wwwjava.util.concurrent是基于Queue(AQS)的并发包，而Queue，很多情况下使用到了Atomic操作同時整个J.U.C都是建立在CAS之上的我們可以使用atomic相關類及CAS思想，建立自定義的安全的數據結構 ATOMIC相關類： 1234基于反射的原子更新字段的值AtomicIntegerFieldUpdater&lt;T&gt;AtomicLongFieldUpdater&lt;T&gt;AtomicReferenceFieldUpdater&lt;T,V&gt; 指令重排序JVM能够根据处理器的特性（CPU的多级缓存系统、多核处理器等）适当的重新排序机器指令，使机器指令更符合CPU的执行特点，最大限度的发挥机器的性能. Happens-before法则如果动作B要看到动作A的执行结果（无论A/B是否在同一个线程里面执行），那么A/B就需要满足happens-before关系. CAS 操作乐观锁用到的机制就是CAS，Compare and Swap。]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collection 關鍵點整理]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2016%2F03%2F27%2F201603271414-JDK-Collection%E9%97%9C%E9%8D%B5%E9%BB%9E%E6%95%B4%E7%90%86.html</url>
    <content type="text"><![CDATA[未完]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Redis設計與實現》讀書筆記-第一部分-第12章]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2016%2F03%2F03%2F201603031922-%E3%80%8ARedis%E8%A8%AD%E8%A8%88%E8%88%87%E5%AF%A6%E7%8F%BE%E3%80%8B%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%AC%AC12%E7%AB%A0.html</url>
    <content type="text"><![CDATA[Redis 事件 相關知識： 總結：]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Redis設計與實現》讀書筆記-第一部分-第11章]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2016%2F03%2F02%2F201603021923-%E3%80%8ARedis%E8%A8%AD%E8%A8%88%E8%88%87%E5%AF%A6%E7%8F%BE%E3%80%8B%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%AC%AC11%E7%AB%A0.html</url>
    <content type="text"><![CDATA[Redis AOF 持久化 相關知識： 總結：]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Redis設計與實現》讀書筆記-第一部分-第十章]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2016%2F03%2F01%2F201603011954-%E3%80%8ARedis%E8%A8%AD%E8%A8%88%E8%88%87%E5%AF%A6%E7%8F%BE%E3%80%8B%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%AC%AC%E5%8D%81%E7%AB%A0.html</url>
    <content type="text"><![CDATA[Redis RDB 持久化 相關知識： 總結：]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Redis設計與實現》讀書筆記-第一部分-第九章]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2016%2F02%2F29%2F201602291918-%E3%80%8ARedis%E8%A8%AD%E8%A8%88%E8%88%87%E5%AF%A6%E7%8F%BE%E3%80%8B%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%AC%AC%E4%B9%9D%E7%AB%A0.html</url>
    <content type="text"><![CDATA[Redis數據庫 相關知識： 總結：]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Redis設計與實現》讀書筆記-第一部分-第八章]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2016%2F02%2F23%2F2016022319-%E3%80%8ARedis%E8%A8%AD%E8%A8%88%E8%88%87%E5%AF%A6%E7%8F%BE%E3%80%8B%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%AC%AC%E5%85%AB%E7%AB%A0.html</url>
    <content type="text"><![CDATA[Redis對象：字符串、列表、集合、哈希、有序集合 概覽： 總結：]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Redis設計與實現》讀書筆記-第一部分-第七章]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2016%2F02%2F22%2F2016022218-%E3%80%8ARedis%E8%A8%AD%E8%A8%88%E8%88%87%E5%AF%A6%E7%8F%BE%E3%80%8B%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%AC%AC%E4%B8%83%E7%AB%A0.html</url>
    <content type="text"><![CDATA[列表鍵與哈希鍵的底層實現數據結構:ziplist 數據結構： 實現：每個壓縮列表節點可以保存一個字節數組或者一個整數連鎖更新 previous_entry_length:前一個節點長度encoding:節點內容類型及長度content:節點內容 總結：]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Redis設計與實現》讀書筆記-第一部分-第六章]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2016%2F02%2F18%2F201602181943-%E3%80%8ARedis%E8%A8%AD%E8%A8%88%E8%88%87%E5%AF%A6%E7%8F%BE%E3%80%8B%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%AC%AC%E5%85%AD%E7%AB%A0.html</url>
    <content type="text"><![CDATA[整數集合，集合鍵的底層實現數據結構:intset 數據結構： 實現：content 數組底層實現類型由encoding決定16、32、64位可根據新增元素類型自由升級，但不能降級1、根據新元素類型，擴展整型集合底層數組空間大小，為新元素分配空間2、將底層數組元素類型轉變為新類型，重新放置到對應的數組位置中,并按照原有次序 位數 * length 計算出元素在數組中的位置3、將新元素添加到底層數組中 總結：]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Redis設計與實現》讀書筆記 - 第一部分 第五章]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2016%2F02%2F17%2F2016021720-%E3%80%8ARedis%E8%A8%AD%E8%A8%88%E8%88%87%E5%AF%A6%E7%8F%BE%E3%80%8B%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%AC%AC%E4%BA%94%E7%AB%A0.html</url>
    <content type="text"><![CDATA[有序集合實現、集群節點實現數據結構 ：zskiplist,zskiplistNode 數據結構： 總結：]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Redis設計與實現》讀書筆記 - 第一部分 第四章]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2016%2F01%2F27%2F201601272042-%E3%80%8ARedis%E8%A8%AD%E8%A8%88%E8%88%87%E5%AF%A6%E7%8F%BE%E3%80%8B%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%AC%AC%E5%9B%9B%E7%AB%A0.html</url>
    <content type="text"><![CDATA[數據庫的底層實現，哈希鍵的底層實習之一字典:主要的三個數據結構 ：dict,dictht,dictEntry 先來一張綜合三個數據結構的圖： 字典：dict:type:類型特定函數privdata:私有數據,用於保存需要傳遞給類型特定函數的可選參數ht:dictht哈希表rehashidx:rehash索引，當前沒有rehash的時候，值為-1 哈希表：dicthttable:哈希表數組dictEntrysize:哈希表大小sizemask:哈希表掩碼，用於計算索引used:已有節點數量 哈希表節點：dictEntrykey:鍵值對Keyv:鍵值對Value,可以是一個指針，一個uint64_t整型，也可以是一個int64_t整型next:指向下一個鍵值對，用於索引相同時，形成鏈錶,解決哈希衝突 字典的底層由哈希表實現，每個哈希表包含多個哈希節點，每個哈希節點包含字典中的一個鍵值對]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Redis設計與實現》讀書筆記 —— 第一部分 第三章]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2016%2F01%2F27%2F201601272023-%E3%80%8ARedis%E8%A8%AD%E8%A8%88%E8%88%87%E5%AF%A6%E7%8F%BE%E3%80%8B%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98-%E2%80%94%E2%80%94-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%AC%AC%E4%B8%89%E7%AB%A0.html</url>
    <content type="text"><![CDATA[這一章非常簡短，介紹Redis底層實現數據結果：鏈錶 Redis鏈錶節點有前置指針，後置指針，當前值域鏈錶結構包含指向節點頭部的head指針，指向節點尾部的tail指針，表示節點個數的len屬性同時包含dup、free、match三個多態鏈錶所需的特定類型函數]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Redis設計與實現》讀書筆記 —— 第一部分 第二章]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2016%2F01%2F06%2F201601062001-%E3%80%8Aredis%E8%A8%AD%E8%A8%88%E8%88%87%E5%AF%A6%E7%8F%BE%E3%80%8B%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98.html</url>
    <content type="text"><![CDATA[閱讀《redis設計與實現》一書筆記作者黃建宏，90年生【90后啊啊啊啊啊第一章主要介紹本書的一些概況以及建議的學習步驟，這裡不記錄，從真正正文Redis第一部分開始 第一部分 數據結構與對象2.簡單動態字符串SDS ( Simple Dynamic String ) Redis中 C字符串只會用於字面量(比如：日誌打印的時候)，需要更改的字符串則使用SDS結構.鍵值對的鍵與值分別保存著字符串XX的SDS結構SDS用作緩衝區(比如：AOF緩衝區，客戶端狀態中的輸入緩衝區) 2.1 SDS的定義123456789101112131415len:記錄buf數組中已使用的字節數量，也就是SDS字符串保存的字符串長度，這個長度，不包含&apos;\0&apos;空字符，SDS自動為字符串數組增加一個&apos;\0&apos;空字符位free：未使用的字節數buf[]:保存字符串，並且以&apos;\0&apos;結尾的字符串，如同C語言一樣，可以直接複用C語言的字符串函數----C字符串遍歷需操作複雜度O(N),而SDS本身擁有len屬性，表示字符串長度，遍歷需要O(1)複雜度，性能提升，即使反復使用strlen命令，也不會造成性能影響C字符串不記錄長度本身，防止緩衝區溢出，對應拼接操作，內存重新分配，需要長度擴容，如果忘記這一步，會造成緩衝區溢出， 對於截斷操作，同樣需要重新分配內存，需要長度縮短，忘記這一步，會造成內存洩露。對於Redis緩存數據庫來講，頻繁的進行內存重新分配，嚴重影響性能。為了避免C語言字符串操作的這種缺陷，SDS通過未使用空間free來解除字符串長度和底層數組長度的關聯。兩種優化策略：空間預分配與惰性空間釋放1、預分配空間：減少連續執行字串增長操作所需的內存重新分配次數,必定N次==》最多N次1》小於1MB數據，free = len = buf數據長度2》大於1MB數據，free = 1MB數據空間 len = buf數據長度2、惰性釋放空間：字符串縮短操作，並不是立即內存充分配，而是將釋放的空間用free標記==》為將來可能有的增長操作做優化SDS同樣提供API來讓我們真正的釋放未使用空間，不會造成內存浪費。 2.2二進制安全C字符串只能保存字符，必須符合某種規範ASCII，如果有空格，會被默認為字符截斷(‘\0’)，而SDS稱之為字節數組，保存內容由len屬性值判斷字符串是否結束，而不是空格，不僅僅可以保存字符，同樣可保存各種二進制數據 2.3兼容C字符串函數SDS結構遵循C字符串以空字符結尾的慣例，可以在有需要的時候，重用函數，避免不必要的代碼重複。 2.4C字符串與SDS之間的對比 2.5重點回顧]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2015年終總結及2016年度計劃]]></title>
    <url>%2Farchives%2F%E7%B8%BD%E7%B5%90%2F2015%2F12%2F31%2F201512312000-2015%E5%B9%B4%E7%B5%82%E7%B8%BD%E7%B5%90%E5%8F%8A2016%E5%B9%B4%E5%BA%A6%E8%A8%88%E5%8A%83.html</url>
    <content type="text"><![CDATA[2015年終總結及2016年度計劃年終總結這東西，是最不喜歡寫的。不單單年終總結不願意寫，一切文字的東西不願意寫。或者與其說是不願意寫，倒不如說是不會寫，不知道該怎麼寫，從小到大，最討厭的就是作文課。可是今天，想寫，想要自己記住這一年！ 2015年終總結為什麼要讓自己記住這一年？或者更準確來說是2014及2015這兩年？因為這兩年可以說是職業生涯中最低谷期，14年從工作了四年的公司離開后，就沒有個穩定工作，換了兩份工作，好在14年在老家學會了開車，考了一個駕照，不然真不知道這兩年我都乾了些什麼事情。09年至今工作也有六年時間了，六年，作為一個搞技術做開發的人來講，六年的時間，但凡是用心一點，都可以達到高級軟件開發工程師的級別，甚至有些還能達到初中級軟件架構師的層次。雖然自己這兩年薪水漲了兩三倍，可是再細細思考來，除了code還會什麼呢？計算機科學基礎的高數忘光了，計算機組成原理不會，操作系統不會，算法數據結構還是不會；應用層面除了會copy代碼刪刪改改的完成業務需求，底層原理還是”知其然卻不知其所以然”。因為工作年限夠長，經常接到獵頭電話推薦工作機會，不需要自己去投簡歷，可總有那麼幾次特別心儀的機會，都因自己底層基礎知識不足而措施掉（最心痛的莫屬阿里支付寶與淘寶兩部門的面試了，知道沒有通過技術面試的那一刻，真是%&gt;_&lt;%）這樣渾渾噩噩的過了14年，又過了15年大半年的時間，也由於兩年間薪水翻倍速度太快，快的已經讓自己像是長了翅膀飛上了天去一樣，然後阿里的幾次面試的失敗，又讓自己像是被硬生生給掰斷了翅膀，從高空中跌落下來~好在15年的最後幾個月，終因阿里面試失敗，喚醒了自己內心不服輸的勁頭，既然自己喜歡技術，喜歡開發，職業規劃也早已認定自己就是要成為軟件架構師，那麼現在的失敗算什麼呢，一切還不晚，一切從頭開始，基礎不好重學基礎，架構不懂，多看多問多參與，基礎扎實了，經驗豐富了，架構就出來了。在15年最後的一個月裡，開始搭建GitHub專有博客，記錄自己的學習過程，最首要的也是最基礎的還是JDK的東西，框架用的多了，但追根溯源，還是最基礎的JDK堆積出來的代碼，所以首先把JDK過一遍，現在選用的是英文版1.7,1.6已經過時，1.8雖然也有公司在用，但是大部分還是1.7版本，公司現在就是用1.8開發，剛入職的時候，開發環境搞了好久才搞定，因為IDEA的配置在1.7-與1.8+的配置不相同，搞到IDEA總是啟動不了，後來一個一個配置測試，才找到不適用的那個并刪除掉。英文版的話，如果是中文的，估計自己會“一目十行”的掠過好多細節問題，而英文，則必須每字每詞都必須看到，并翻譯出中文才行，當然自己的英文水平只能這樣~，不過開頭的兩三聽很累腦子，但後面就輕快了許多，也是學英文的一種方法吧。不過最近沒什麼時間開JDK了，公司實在太忙，不是敲代碼的忙，而是新模塊功能需求分析，概要設計等等這些工作，太費腦力，之前同事說過程序員做到最後不就是為了寫文檔嗎？如果你仍然只是為了敲代碼，那你永遠都進步不了。確實，如果我的目標是架構師，那麼初期這些文檔就是鍛煉自己能力的一個最好途徑。對了，15年還做了一件比較滿意的事情，就是從三月一號（過完15年的春節放假回來上班第一天，記得很清楚）開始，補習英文！那一天測試詞匯量應該是不足2K（不誇張），所有英文文法不會，上段說的看JDK英文版，如果是那時候看，估計就不是頭兩三天吃力的情況了，壓根就像是一點都沒學過英文的人一樣，什麼邏輯都沒有，但從那一天開始，單詞，語法，閱讀，聽力，同步補習，10年前買的新概念終於拿出來了~雖然現在仍然沒有學完第二冊，不過由於這一年的時間算是斷斷續續的都在學習，總算是基礎文法知道了，看到英文句子也能大概翻譯出來了，雖然翻譯的不像筆譯也不像口譯，嘛自己懂就行了，循序漸進嘛，總不能學了二十年都不會的東西，一年就讓我搞定吧~~總的來說還是有進步滴ww 2016年度計劃前面寫了一大堆為什麼寫總結以及這兩年經歷了些什麼。這裡就做一個簡單的16年度計劃吧，敦促一下自己，也鼓勵自己，夢想就在前面，只要你往前衝，而且正值青春，磕磕碰碰怕什麼？怕，就輸一輩子。根據現在的工作安排，估計16年前三個月1,2,3月份都要把經歷放到工作中，學習JDK的計劃，應該不會像之前每天都進行，不過也不會斷掉，週末或許可以來一段時間學習一個包的類w預估到6月份把整個JDK常用結構都過一遍，只是常用的，像AWT這樣的就先不關注了。而下半年的時間，工作之外的主要精力將放到整個計算機基礎中的重頭戲：算法與數據結構 上面，真真是從零開始，把常見的算法都要搞明白，偽代碼快速編寫，使用場景，時間複雜度，空間複雜度等等，這就不像是JDK那樣過一遍了，而是要深入其中，務必把學到的每一個都深深引入到腦海里！當然要達到這個效果，也不是一朝一夕的，所以也是一個循序漸進的過程，整個下半年會把重心放到這裡，17年的話會持續，但應該會有其他的安排，這個具體還要看16年的一個整體計劃實施程度。這基本上是16年的兩個大的方向，但不限於只關注這兩個部分，仍會關注工作中遇到的問題及解決方案，比如，現在大多數公司緩存系統都是用REDIS，那麼對於REDIS的深入了解也是勢在必行的，這部分，現在也看了一些，不過都是基礎部分，關於分佈式，分佈式事務等高級部分還沒有看到，這也將是16年要做的事情，在工作之餘，不過投入時間比例會相對較少。還有其他的分佈式DUBBO通信服務，分佈式ZOOKEEPER協調工具，這些等等，都不能只停留在會使用，會搭建，會配置的基礎上，那隻是運維人員的工作任務，作為開發人員，對他的底層還要深入了解的。上面所說的一切都不單單是代碼層次的理解，而是這些架構設計者的思想，軟件開發，思想最為重要，如果只會代碼，不懂思想，架構師只能是一個遙無止境的夢而已。然後，英文！也要繼續，做到英文技術文檔首次閱讀如同母語一般理解程度，TED演講無字幕也可以聽棟90%以上，口語，書寫英文文檔更高要求。這些，不僅僅是16年，17年，18年要做的事情，而是一個永遠的進行式~最後還有日文！對，因為夢幻的寶塚！日文也是斷斷續續學了有三兩年時間了，我是覺得比起英文，我的日文水平高多了www還是一個持續的過程！ 寫了這麼多，語句也不通順，不過是給自己記錄下現在的心情，以及未來要做的事情，自己開的懂就好。:-D 希望終有一天自己能夠真真正正的做的了架構，搞的定後端，寫得好前端，管得了團隊，經得住扯皮的全站程序員。 夢想還是要有的，萬一實現了呢~~ 以上:-D]]></content>
      <categories>
        <category>總結</category>
      </categories>
      <tags>
        <tag>職場</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[並發包J.U.C相關 -- ConcurrentHashMap -- (34)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F23%2F201512231629-%E4%B8%A6%E7%99%BC%E5%8C%85J-U-C%E7%9B%B8%E9%97%9C-ConcurrentHashMap-34.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 ConcurrentHashMap 詳解 (31)這一節主要學習集合框架中的 ConcurrentHashMap 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ ConcurrentHashMap 說明:ConcurrentHashMap UML: ConcurrentHashMap 源碼解析:]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[並發包 J.U.C 相關 -- ConcurrentMap -- (33)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F23%2F201512231602-%E4%B8%A6%E7%99%BC%E5%8C%85J-U-C%E7%9B%B8%E9%97%9C-33.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 並發包下的集合 ConcurrentMap 詳解 (30)這一節主要學習集合框架中的 並發包下的集合 ConcurrentMap相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ ConcurrentMap 說明: 並發包下的Map接口 ConcurrentMap UML: ConcurrentMap 源碼解析:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/** * If the specified key is not already associated * 如果指定的key沒有關聯一個值，關聯他用給定的值 * with a value, associate it with the given value. * This is equivalent to * 這相等於 * &lt;pre&gt; * if (!map.containsKey(key)) * return map.put(key, value); * else * return map.get(key);&lt;/pre&gt; * except that the action is performed atomically. * 除非這個操作自動執行 * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with the specified key, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with the key, * if the implementation supports null values.) * @throws UnsupportedOperationException if the &lt;tt&gt;put&lt;/tt&gt; operation * is not supported by this map * @throws ClassCastException if the class of the specified key or value * prevents it from being stored in this map * @throws NullPointerException if the specified key or value is null, * and this map does not permit null keys or values * @throws IllegalArgumentException if some property of the specified key * or value prevents it from being stored in this map * */ V putIfAbsent(K key, V value); /** * Removes the entry for a key only if currently mapped to a given value. * 移出實體從一個key僅僅當前影射了給定的value * This is equivalent to * &lt;pre&gt; * if (map.containsKey(key) &amp;amp;&amp;amp; map.get(key).equals(value)) &#123; * map.remove(key); * return true; * &#125; else return false;&lt;/pre&gt; * except that the action is performed atomically. * * @param key key with which the specified value is associated * @param value value expected to be associated with the specified key * @return &lt;tt&gt;true&lt;/tt&gt; if the value was removed * @throws UnsupportedOperationException if the &lt;tt&gt;remove&lt;/tt&gt; operation * is not supported by this map * @throws ClassCastException if the key or value is of an inappropriate * type for this map * (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified key or value is null, * and this map does not permit null keys or values * (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) */ boolean remove(Object key, Object value); /** * Replaces the entry for a key only if currently mapped to a given value. * 替換 * This is equivalent to * &lt;pre&gt; * if (map.containsKey(key) &amp;amp;&amp;amp; map.get(key).equals(oldValue)) &#123; * map.put(key, newValue); * return true; * &#125; else return false;&lt;/pre&gt; * except that the action is performed atomically. * * @param key key with which the specified value is associated * @param oldValue value expected to be associated with the specified key * @param newValue value to be associated with the specified key * @return &lt;tt&gt;true&lt;/tt&gt; if the value was replaced * @throws UnsupportedOperationException if the &lt;tt&gt;put&lt;/tt&gt; operation * is not supported by this map * @throws ClassCastException if the class of a specified key or value * prevents it from being stored in this map * @throws NullPointerException if a specified key or value is null, * and this map does not permit null keys or values * @throws IllegalArgumentException if some property of a specified key * or value prevents it from being stored in this map */ boolean replace(K key, V oldValue, V newValue); /** * Replaces the entry for a key only if currently mapped to some value. * This is equivalent to * &lt;pre&gt; * if (map.containsKey(key)) &#123; * return map.put(key, value); * &#125; else return null;&lt;/pre&gt; * except that the action is performed atomically. * * @param key key with which the specified value is associated * @param value value to be associated with the specified key * @return the previous value associated with the specified key, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with the key, * if the implementation supports null values.) * @throws UnsupportedOperationException if the &lt;tt&gt;put&lt;/tt&gt; operation * is not supported by this map * @throws ClassCastException if the class of the specified key or value * prevents it from being stored in this map * @throws NullPointerException if the specified key or value is null, * and this map does not permit null keys or values * @throws IllegalArgumentException if some property of the specified key * or value prevents it from being stored in this map */ V replace(K key, V value);]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- LinkedHashSet -- (32)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F21%2F201512211956-Collections-LinkedHashSet.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 LinkedHashSet 詳解 (29)這一節主要學習集合框架中的 LinkedHashSet 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ LinkedHashSet UML: LinkedHashSet 源碼解析:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Constructs a new, empty linked hash set with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity of the linked hash set * @param loadFactor the load factor of the linked hash set * @throws IllegalArgumentException if the initial capacity is less * than zero, or if the load factor is nonpositive */public LinkedHashSet(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor, true);&#125;/** * Constructs a new, empty linked hash set with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity of the LinkedHashSet * @throws IllegalArgumentException if the initial capacity is less * than zero */public LinkedHashSet(int initialCapacity) &#123; super(initialCapacity, .75f, true);&#125;/** * Constructs a new, empty linked hash set with the default initial * capacity (16) and load factor (0.75). */public LinkedHashSet() &#123; super(16, .75f, true);&#125;/** * Constructs a new linked hash set with the same elements as the * specified collection. The linked hash set is created with an initial * capacity sufficient to hold the elements in the specified collection * and the default load factor (0.75). * * @param c the collection whose elements are to be placed into * this set * @throws NullPointerException if the specified collection is null */public LinkedHashSet( Collection&lt;? extends E&gt; c) &#123; super(Math.max(2*c.size(), 11), .75f, true); addAll(c);&#125;]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- HashSet -- (31)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F21%2F201512211938-Collections-HashSet.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 HashSet 詳解 (28)這一節主要學習集合框架中的 HashSet 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ HashSet 說明: private transient HashMap map; HashSet UML: HashSet 源碼解析:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162/** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * default initial capacity (16) and load factor (0.75). */public HashSet() &#123; map = new HashMap&lt;&gt;();&#125;/** * Constructs a new set containing the elements in the specified * collection. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with default load factor * (0.75) and an initial capacity sufficient to contain the elements in * the specified collection. * * @param c the collection whose elements are to be placed into this set * @throws NullPointerException if the specified collection is null */public HashSet( Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;( Math.max( (int) ( c.size() / .75f) + 1, 16)); addAll(c);&#125;/** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * the specified initial capacity and the specified load factor. * * @param initialCapacity the initial capacity of the hash map * @param loadFactor the load factor of the hash map * @throws IllegalArgumentException if the initial capacity is less * than zero, or if the load factor is nonpositive */public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;( initialCapacity, loadFactor);&#125;/** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * the specified initial capacity and default load factor (0.75). * * @param initialCapacity the initial capacity of the hash table * @throws IllegalArgumentException if the initial capacity is less * than zero */public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;( initialCapacity);&#125;/** * Constructs a new, empty linked hash set. (This package private * constructor is only used by LinkedHashSet.) The backing * HashMap instance is a LinkedHashMap with the specified initial * capacity and the specified load factor. * * @param initialCapacity the initial capacity of the hash map * @param loadFactor the load factor of the hash map * @param dummy ignored (distinguishes this * constructor from other int, float constructor.) * @throws IllegalArgumentException if the initial capacity is less * than zero, or if the load factor is nonpositive */HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;( initialCapacity, loadFactor);&#125;/** * Returns an iterator over the elements in this set. The elements * are returned in no particular order. * * @return an Iterator over the elements in this set * @see ConcurrentModificationException */public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator();&#125;/** * Returns the number of elements in this set (its cardinality). * * @return the number of elements in this set (its cardinality) */public int size() &#123; return map.size();&#125;/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements. * * @return &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements */public boolean isEmpty() &#123; return map.isEmpty();&#125;/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified element. * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this set * contains an element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;. * * @param o element whose presence in this set is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified element */public boolean contains(Object o) &#123; return map.containsKey(o);&#125;/** * Adds the specified element to this set if it is not already present. * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;. * * @param e element to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified * element */public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125;/** * Removes the specified element from this set if it is present. * More formally, removes an element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;, * if this set contains such an element. Returns &lt;tt&gt;true&lt;/tt&gt; if * this set contained the element (or equivalently, if this set * changed as a result of the call). (This set will not contain the * element once the call returns.) * * @param o object to be removed from this set, if present * @return &lt;tt&gt;true&lt;/tt&gt; if the set contained the specified element */public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125;/** * Removes all of the elements from this set. * The set will be empty after this call returns. */public void clear() &#123; map.clear();&#125;/** * Returns a shallow copy of this &lt;tt&gt;HashSet&lt;/tt&gt; instance: the elements * themselves are not cloned. * * @return a shallow copy of this set */public Object clone() &#123; try &#123; HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone(); newSet.map = ( HashMap&lt;E, Object&gt; ) map.clone(); return newSet; &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125;&#125;]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- TreeSet -- (30)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F21%2F2015122119-Collections-TreeSet.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 TreeSet 詳解 (27)這一節主要學習集合框架中的 TreeSet 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ TreeSet 說明: Note that this implementation is not synchronizedThe iterators returned by this class’s iterator method are fail-fast TreeSet UML:]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- TreeMap -- (29)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F18%2F2015121810-Collections-TreeMap.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 TreeMap 詳解 (26)由於 TreeSet,HashSet 引用了 Map 實現,所以這一節先學習 Map 接口相關這一節主要學習集合框架中的 TreeMap 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ TreeMap 說明: A Red-Black tree based NavigableMap implementationNote that this implementation is not synchronizedThe iterators returned by the iterator method of the collections returned by all of this class’s “collection view methods” are fail-fast這章看到頭疼，大概了解一二了，不過對於紅黑樹實現還是模模糊糊，先放過這章，日後再回頭重看吧，現在腦子混混的. TreeMap UML: TreeMap 源碼解析:1234567891011121314151617181920212223242526272829303132/** * Returns a shallow copy of this &#123;@code TreeMap&#125; instance. (The keys and * values themselves are not cloned.) * * @return a shallow copy of this map */public Object clone() &#123; TreeMap&lt;K,V&gt; clone = null; try &#123; clone = (TreeMap&lt;K,V&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; // Put clone into &quot;virgin&quot; state (except for comparator) clone.root = null; clone.size = 0; clone.modCount = 0; clone.entrySet = null; clone.navigableKeySet = null; clone.descendingMap = null; // Initialize clone with our mappings try &#123; clone.buildFromSorted(size, entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125; return clone;&#125;]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- LinkedHashMap -- (28)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F17%2F2015121716-Collections-LinkedHashMap.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 LinkedHashMap 詳解 (25)由於 TreeSet,HashSet 引用了 Map 實現,所以這一節先學習 Map 接口相關這一節主要學習集合框架中的 LinkedHashMap 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ LinkedHashMap 說明: Iteration over the collection-views of a LinkedHashMap requires time proportional to the size of the map, regardless of its capacity.Iteration over a HashMap is likely to be more expensive, requiring time proportional to its capacity1private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123; ... &#125; LinkedHashMap UML: LinkedHashMap 源碼解析:1234567891011121314151617181920/** * Transfers all entries to new table array. This method is called * 轉換所有的entries到新的數組中 * by superclass resize. It is overridden for performance, as it is * 這個方法在子類重新size的時候調用 * faster to iterate using our linked list. * 為性能而複寫，用這個鏈錶迭代器更快速 */@Overridevoid transfer( HashMap.Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; for (Entry&lt;K,V&gt; e = header.after; e != header; e = e.after) &#123; if (rehash) e.hash = (e.key == null) ? 0 : hash(e.key); int index = indexFor(e.hash, newCapacity); // 取索引 hash &amp; (length - 1) ,&amp; 性能高於 模運算 e.next = newTable[index]; newTable[index] = e; &#125;&#125;]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- HashMap -- (27)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F15%2F029-Collections-HashMap.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 HashMap 詳解 (24)由於 TreeSet,HashSet 引用了 Map 實現,所以這一節先學習 Map 接口相關這一節主要學習集合框架中的 HashMap 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ HashMap 說明: This implementation provides all of the optional map operations, and permits null values and the null key.As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs1static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; ... &#125; HashMap UML: HashMap 源碼解析:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130 /** * The default initial capacity - MUST be a power of two. * 默認的初始化容量 - 必須是2的冪數 */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 左移4位，就是2的4次方=16 /** * The maximum capacity, used if a higher value is implicitly specified * 最大的容量，用於如果一個更大值隱含的由任何一個帶參的構造器指定 * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. * 其值必須小於 1 &lt;&lt; 30; */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * The load factor used when none specified in constructor. * 當構造函數未指定時的負載因子 */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * An empty table instance to share when the table is not inflated. * 為填充表共享一個空的表實例 */ static final Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;; /** * The table, resized as necessary. Length MUST Always be a power of two. * 重新設置值的表，長度必須是2的冪數 */ transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; /** * The number of key-value mappings contained in this map. * map中k-v影射包含的數量 */ transient int size; /** * The next size value at which to resize (capacity * load factor). * 用於重新設置值的值，閥值 * @serial */ // If table == EMPTY_TABLE then this is the initial capacity at which the// 如果table == EMPTY_TABLE 那麼初始的容量在table創建時 // table will be created when inflated. int threshold; /** * The load factor for the hash table. * 哈希表的負載因子 * * @serial */ final float loadFactor; /** * The number of times this HashMap has been structurally modified * HashMap結構化改變的次數 * Structural modifications are those that change the number of mappings in * 在hashMap中影射的改變或者 * the HashMap or otherwise modify its internal structure (e.g., * 內部結構的改變(例如rehash) * rehash). This field is used to make iterators on Collection-views of * the HashMap fail-fast. (See ConcurrentModificationException). * 這個域用於HahsMap快速失敗集合視圖上的迭代器 */ transient int modCount; /** * The default threshold of map capacity above which alternative hashing is * 默認的超過替代散列的map容量的閥值用於字符串key * used for String keys. Alternative hashing reduces the incidence of * 替代散列減少發生碰撞提供對於字符串key的弱的代碼計算 * collisions due to weak hash code calculation for String keys. * &lt;p/&gt; * This value may be overridden by defining the system property * 這個值可以重寫由系統屬性定義 * &#123;@code jdk.map.althashing.threshold&#125;. A property value of &#123;@code 1&#125; * forces alternative hashing to be used at all times whereas * 一個屬性值1 強迫在任何時間替代散列，而-1則確保任何時間都不會用到 * &#123;@code -1&#125; value ensures that alternative hashing is never used. */ static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE; /** * Returns index for hash code h. * 返回哈希值的索引 */ static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;; return h &amp; (length-1); &#125; /** * Adds a new entry with the specified key, value and hash code to * 添加一個新的實體由指定的key，value以及哈希值到指定的塊中 * the specified bucket. It is the responsibility of this * method to resize the table if appropriate. * 這個方法響應的重新resize適當的表 * * Subclass overrides this to alter the behavior of put method. */ void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex); &#125; /** * Like addEntry except that this version is used when creating entries * 如同addEntry期望的這個版本用於當創建entries作為map構造器或偽構造器一部分時 * as part of Map construction or &quot;pseudo-construction&quot; (cloning, * deserialization). This version needn&apos;t worry about resizing the table. * 這個版本不需要擔心重新resize表 * * Subclass overrides this to alter the behavior of HashMap(Map), * clone, and readObject. */ void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++; &#125;]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- AbstractMap -- (26)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F15%2F028-Collections-AbstractMap.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 AbstractMap 詳解 (23)由於 TreeSet,HashSet 引用了 Map 實現,所以這一節先學習 Map 接口相關這一節主要學習集合框架中的 AbstractMap 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ AbstractMap 說明: 內部類1public static class SimpleImmutableEntry&lt;K,V&gt; &#123; ... &#125; // thread-safe AbstractMap UML: AbstractMap 源碼解析:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * &#123;@inheritDoc&#125; * * &lt;p&gt;This implementation iterates over &lt;tt&gt;entrySet()&lt;/tt&gt; searching * for an entry with the specified value. If such an entry is found, * &lt;tt&gt;true&lt;/tt&gt; is returned. If the iteration terminates without * finding such an entry, &lt;tt&gt;false&lt;/tt&gt; is returned. Note that this * implementation requires linear time in the size of the map. * * @throws ClassCastException &#123;@inheritDoc&#125; * @throws NullPointerException &#123;@inheritDoc&#125; */public boolean containsValue(Object value) &#123; Iterator&lt; Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); if (value==null) &#123; while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); if (e.getValue()==null) return true; &#125; &#125; else &#123; while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); if (value.equals(e.getValue())) return true; &#125; &#125; return false;&#125;/** * &#123;@inheritDoc&#125; * * &lt;p&gt;This implementation iterates over &lt;tt&gt;entrySet()&lt;/tt&gt; searching * for an entry with the specified key. If such an entry is found, * &lt;tt&gt;true&lt;/tt&gt; is returned. If the iteration terminates without * finding such an entry, &lt;tt&gt;false&lt;/tt&gt; is returned. Note that this * implementation requires linear time in the size of the map; many * implementations will override this method. * * @throws ClassCastException &#123;@inheritDoc&#125; * @throws NullPointerException &#123;@inheritDoc&#125; */public boolean containsKey(Object key) &#123; Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); if (key==null) &#123; while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); if (e.getKey()==null) return true; &#125; &#125; else &#123; while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); if (key.equals(e.getKey())) return true; &#125; &#125; return false;&#125;/** * &#123;@inheritDoc&#125; * * &lt;p&gt;This implementation iterates over &lt;tt&gt;entrySet()&lt;/tt&gt; searching * for an entry with the specified key. If such an entry is found, * the entry&apos;s value is returned. If the iteration terminates without * finding such an entry, &lt;tt&gt;null&lt;/tt&gt; is returned. Note that this * implementation requires linear time in the size of the map; many * implementations will override this method. * * @throws ClassCastException &#123;@inheritDoc&#125; * @throws NullPointerException &#123;@inheritDoc&#125; */public V get(Object key) &#123; Iterator&lt; Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); if (key==null) &#123; while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); if (e.getKey()==null) return e.getValue(); &#125; &#125; else &#123; while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); if (key.equals(e.getKey())) return e.getValue(); &#125; &#125; return null;&#125;]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- NavigableMap -- (25)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F15%2F027-Collections-NavigableMap.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 NavigableMap 詳解 (22)由於 TreeSet,HashSet 引用了 Map 實現,所以這一節先學習 Map 接口相關這一節主要學習集合框架中的 NavigableMap 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ NavigableMap UML: NavigableMap 源碼解析:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175/** * Returns a key-value mapping associated with the greatest key * less than or equal to the given key, or &#123;@code null&#125; if there * is no such key. * * @param key the key * @return an entry with the greatest key less than or equal to * &#123;@code key&#125;, or &#123;@code null&#125; if there is no such key * @throws ClassCastException if the specified key cannot be compared * with the keys currently in the map * @throws NullPointerException if the specified key is null * and this map does not permit null keys */Entry&lt;K,V&gt; floorEntry( K key);/** * Returns a key-value mapping associated with the least key * 關聯 * greater than or equal to the given key, or &#123;@code null&#125; if * there is no such key. * * @param key the key * @return an entry with the least key greater than or equal to * &#123;@code key&#125;, or &#123;@code null&#125; if there is no such key * @throws ClassCastException if the specified key cannot be compared * with the keys currently in the map * @throws NullPointerException if the specified key is null * and this map does not permit null keys */Entry&lt;K,V&gt; ceilingEntry( K key);/** * Returns a reverse order view of the mappings contained in this map. * The descending map is backed by this map, so changes to the map are * reflected in the descending map, and vice-versa. If either map is * modified while an iteration over a collection view of either map * is in progress (except through the iterator&apos;s own &#123;@code remove&#125; * operation), the results of the iteration are undefined. * * &lt;p&gt;The returned map has an ordering equivalent to * &lt;tt&gt;&#123;@link Collections#reverseOrder(Comparator) Collections.reverseOrder&#125;(comparator())&lt;/tt&gt;. * The expression &#123;@code m.descendingMap().descendingMap()&#125; returns a * view of &#123;@code m&#125; essentially equivalent to &#123;@code m&#125;. * * @return a reverse order view of this map */NavigableMap&lt;K,V&gt; descendingMap();/** * Returns a &#123;@link java.util.NavigableSet&#125; view of the keys contained in this map. * The set&apos;s iterator returns the keys in ascending order. * The set is backed by the map, so changes to the map are reflected in * the set, and vice-versa. If the map is modified while an iteration * over the set is in progress (except through the iterator&apos;s own &#123;@code * remove&#125; operation), the results of the iteration are undefined. The * set supports element removal, which removes the corresponding mapping * from the map, via the &#123;@code Iterator.remove&#125;, &#123;@code Set.remove&#125;, * &#123;@code removeAll&#125;, &#123;@code retainAll&#125;, and &#123;@code clear&#125; operations. * It does not support the &#123;@code add&#125; or &#123;@code addAll&#125; operations. * * @return a navigable set view of the keys in this map */NavigableSet&lt;K&gt; navigableKeySet();/** * Returns a reverse order &#123;@link java.util.NavigableSet&#125; view of the keys contained in this map. * The set&apos;s iterator returns the keys in descending order. * The set is backed by the map, so changes to the map are reflected in * the set, and vice-versa. If the map is modified while an iteration * over the set is in progress (except through the iterator&apos;s own &#123;@code * remove&#125; operation), the results of the iteration are undefined. The * set supports element removal, which removes the corresponding mapping * from the map, via the &#123;@code Iterator.remove&#125;, &#123;@code Set.remove&#125;, * &#123;@code removeAll&#125;, &#123;@code retainAll&#125;, and &#123;@code clear&#125; operations. * It does not support the &#123;@code add&#125; or &#123;@code addAll&#125; operations. * * @return a reverse order navigable set view of the keys in this map */NavigableSet&lt;K&gt; descendingKeySet();/** * Returns a view of the portion of this map whose keys range from * &#123;@code fromKey&#125; to &#123;@code toKey&#125;. If &#123;@code fromKey&#125; and * &#123;@code toKey&#125; are equal, the returned map is empty unless * &#123;@code fromInclusive&#125; and &#123;@code toInclusive&#125; are both true. The * returned map is backed by this map, so changes in the returned map are * reflected in this map, and vice-versa. The returned map supports all * optional map operations that this map supports. * * &lt;p&gt;The returned map will throw an &#123;@code IllegalArgumentException&#125; * on an attempt to insert a key outside of its range, or to construct a * submap either of whose endpoints lie outside its range. * * @param fromKey low endpoint of the keys in the returned map * @param fromInclusive &#123;@code true&#125; if the low endpoint * is to be included in the returned view * @param toKey high endpoint of the keys in the returned map * @param toInclusive &#123;@code true&#125; if the high endpoint * is to be included in the returned view * @return a view of the portion of this map whose keys range from * &#123;@code fromKey&#125; to &#123;@code toKey&#125; * @throws ClassCastException if &#123;@code fromKey&#125; and &#123;@code toKey&#125; * cannot be compared to one another using this map&apos;s comparator * (or, if the map has no comparator, using natural ordering). * Implementations may, but are not required to, throw this * exception if &#123;@code fromKey&#125; or &#123;@code toKey&#125; * cannot be compared to keys currently in the map. * @throws NullPointerException if &#123;@code fromKey&#125; or &#123;@code toKey&#125; * is null and this map does not permit null keys * @throws IllegalArgumentException if &#123;@code fromKey&#125; is greater than * &#123;@code toKey&#125;; or if this map itself has a restricted * range, and &#123;@code fromKey&#125; or &#123;@code toKey&#125; lies * outside the bounds of the range */NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive);/** * Returns a view of the portion of this map whose keys are less than (or * equal to, if &#123;@code inclusive&#125; is true) &#123;@code toKey&#125;. The returned * map is backed by this map, so changes in the returned map are reflected * in this map, and vice-versa. The returned map supports all optional * map operations that this map supports. * * &lt;p&gt;The returned map will throw an &#123;@code IllegalArgumentException&#125; * on an attempt to insert a key outside its range. * * @param toKey high endpoint of the keys in the returned map * @param inclusive &#123;@code true&#125; if the high endpoint * is to be included in the returned view * @return a view of the portion of this map whose keys are less than * (or equal to, if &#123;@code inclusive&#125; is true) &#123;@code toKey&#125; * @throws ClassCastException if &#123;@code toKey&#125; is not compatible * with this map&apos;s comparator (or, if the map has no comparator, * if &#123;@code toKey&#125; does not implement &#123;@link Comparable&#125;). * Implementations may, but are not required to, throw this * exception if &#123;@code toKey&#125; cannot be compared to keys * currently in the map. * @throws NullPointerException if &#123;@code toKey&#125; is null * and this map does not permit null keys * @throws IllegalArgumentException if this map itself has a * restricted range, and &#123;@code toKey&#125; lies outside the * bounds of the range */NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive);/** * Returns a view of the portion of this map whose keys are greater than (or * equal to, if &#123;@code inclusive&#125; is true) &#123;@code fromKey&#125;. The returned * map is backed by this map, so changes in the returned map are reflected * in this map, and vice-versa. The returned map supports all optional * map operations that this map supports. * * &lt;p&gt;The returned map will throw an &#123;@code IllegalArgumentException&#125; * on an attempt to insert a key outside its range. * * @param fromKey low endpoint of the keys in the returned map * @param inclusive &#123;@code true&#125; if the low endpoint * is to be included in the returned view * @return a view of the portion of this map whose keys are greater than * (or equal to, if &#123;@code inclusive&#125; is true) &#123;@code fromKey&#125; * @throws ClassCastException if &#123;@code fromKey&#125; is not compatible * with this map&apos;s comparator (or, if the map has no comparator, * if &#123;@code fromKey&#125; does not implement &#123;@link Comparable&#125;). * Implementations may, but are not required to, throw this * exception if &#123;@code fromKey&#125; cannot be compared to keys * currently in the map. * @throws NullPointerException if &#123;@code fromKey&#125; is null * and this map does not permit null keys * @throws IllegalArgumentException if this map itself has a * restricted range, and &#123;@code fromKey&#125; lies outside the * bounds of the range */NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive);]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- SortedMap -- (24)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F15%2F026-Collections-SortedMap.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 SortedMap 詳解 (21)由於 TreeSet,HashSet 引用了 Map 實現,所以這一節先學習 Map 接口相關這一節主要學習集合框架中的 SortedMap 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ SortedMap UML:]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- Map -- (23)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F15%2F025-Collections-Map.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 Map 詳解 (20)由於 TreeSet,HashSet 引用了 Map 實現,所以這一節先學習 Map 接口相關這一節主要學習集合框架中的 Map 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ Map 說明: 內部接口 : interface Entry { … } Map UML: Map 源碼解析:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified * key. More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if * this map contains a mapping for a key &lt;tt&gt;k&lt;/tt&gt; such that * &lt;tt&gt;(key==null ? k==null : key.equals(k))&lt;/tt&gt;. (There can be * at most one such mapping.) * * @param key key whose presence in this map is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified * key * @throws ClassCastException if the key is of an inappropriate type for * this map * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified key is null and this map * does not permit null keys * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) */boolean containsKey(Object key);/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the * specified value. More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if * this map contains at least one mapping to a value &lt;tt&gt;v&lt;/tt&gt; such that * &lt;tt&gt;(value==null ? v==null : value.equals(v))&lt;/tt&gt;. This operation * will probably require time linear in the map size for most * implementations of the &lt;tt&gt;Map&lt;/tt&gt; interface. * * @param value value whose presence in this map is to be tested * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the * specified value * @throws ClassCastException if the value is of an inappropriate type for * this map * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified value is null and this * map does not permit null values * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) */boolean containsValue(Object value); /** * Associates the specified value with the specified key in this map * 關聯 * (optional operation). If the map previously contained a mapping for * 如果集合先前包含了key的影射 * the key, the old value is replaced by the specified value. (A map * 舊值會由指定的值指定 * &lt;tt&gt;m&lt;/tt&gt; is said to contain a mapping for a key &lt;tt&gt;k&lt;/tt&gt; if and only * if &#123;@link #containsKey(Object) m.containsKey(k)&#125; would return * &lt;tt&gt;true&lt;/tt&gt;.) * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;, * if the implementation supports &lt;tt&gt;null&lt;/tt&gt; values.) * @throws UnsupportedOperationException if the &lt;tt&gt;put&lt;/tt&gt; operation * is not supported by this map * @throws ClassCastException if the class of the specified key or value * prevents it from being stored in this map * @throws NullPointerException if the specified key or value is null * and this map does not permit null keys or values * @throws IllegalArgumentException if some property of the specified key * or value prevents it from being stored in this map */V put(K key, V value); /** * Removes the mapping for a key from this map if it is present * (optional operation). More formally, if this map contains a mapping * from key &lt;tt&gt;k&lt;/tt&gt; to value &lt;tt&gt;v&lt;/tt&gt; such that * &lt;code&gt;(key==null ? k==null : key.equals(k))&lt;/code&gt;, that mapping * is removed. (The map can contain at most one such mapping.) * * &lt;p&gt;Returns the value to which this map previously associated the key, * 返回先前map中關聯這個key的值 * or &lt;tt&gt;null&lt;/tt&gt; if the map contained no mapping for the key. * 如果沒有影射返回null * * &lt;p&gt;If this map permits null values, then a return value of * &lt;tt&gt;null&lt;/tt&gt; does not &lt;i&gt;necessarily&lt;/i&gt; indicate that the map * contained no mapping for the key; it&apos;s also possible that the map * explicitly mapped the key to &lt;tt&gt;null&lt;/tt&gt;. * * &lt;p&gt;The map will not contain a mapping for the specified key once the * call returns. * * @param key key whose mapping is to be removed from the map * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * @throws UnsupportedOperationException if the &lt;tt&gt;remove&lt;/tt&gt; operation * is not supported by this map * @throws ClassCastException if the key is of an inappropriate type for * this map * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified key is null and this * map does not permit null keys * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) */V remove(Object key);]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- NavigableSet -- (22)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F15%2F024-Collections-NavigableSet.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 NavigableSet 詳解 (19)這一節主要學習集合框架中的 NavigableSet 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ NavigableSet 說明:NavigableSet UML: NavigableSet 源碼解析:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/** * Returns a reverse order view of the elements contained in this set. * 返回這個集合包含元素相反的視圖 * The descending set is backed by this set, so changes to the set are * 倒序的set基於這個set * reflected in the descending set, and vice-versa. If either set is * 在倒序的set中改變這個結合是引用的，反之亦然 * modified while an iteration over either set is in progress (except * 如果任意set當迭代任意set在過程中 * through the iterator&apos;s own &#123;@code remove&#125; operation), the results of * the iteration are undefined. * 迭代的結果是為定義的 * * &lt;p&gt;The returned set has an ordering equivalent to * &lt;tt&gt;&#123;@link Collections#reverseOrder(Comparator) Collections.reverseOrder&#125;(comparator())&lt;/tt&gt;. * The expression &#123;@code s.descendingSet().descendingSet()&#125; returns a * view of &#123;@code s&#125; essentially equivalent to &#123;@code s&#125;. * * @return a reverse order view of this set */NavigableSet&lt;E&gt; descendingSet();/** * Returns an iterator over the elements in this set, in descending order. * Equivalent in effect to &#123;@code descendingSet().iterator()&#125;. * * @return an iterator over the elements in this set, in descending order */Iterator&lt;E&gt; descendingIterator();/** * Returns a view of the portion of this set whose elements range from * &#123;@code fromElement&#125; to &#123;@code toElement&#125;. If &#123;@code fromElement&#125; and * &#123;@code toElement&#125; are equal, the returned set is empty unless &#123;@code * fromInclusive&#125; and &#123;@code toInclusive&#125; are both true. The returned set * is backed by this set, so changes in the returned set are reflected in * this set, and vice-versa. The returned set supports all optional set * operations that this set supports. * * &lt;p&gt;The returned set will throw an &#123;@code IllegalArgumentException&#125; * on an attempt to insert an element outside its range. * * @param fromElement low endpoint of the returned set * @param fromInclusive &#123;@code true&#125; if the low endpoint * is to be included in the returned view * @param toElement high endpoint of the returned set * @param toInclusive &#123;@code true&#125; if the high endpoint * is to be included in the returned view * @return a view of the portion of this set whose elements range from * &#123;@code fromElement&#125;, inclusive, to &#123;@code toElement&#125;, exclusive * @throws ClassCastException if &#123;@code fromElement&#125; and * &#123;@code toElement&#125; cannot be compared to one another using this * set&apos;s comparator (or, if the set has no comparator, using * natural ordering). Implementations may, but are not required * to, throw this exception if &#123;@code fromElement&#125; or * &#123;@code toElement&#125; cannot be compared to elements currently in * the set. * @throws NullPointerException if &#123;@code fromElement&#125; or * &#123;@code toElement&#125; is null and this set does * not permit null elements * @throws IllegalArgumentException if &#123;@code fromElement&#125; is * greater than &#123;@code toElement&#125;; or if this set itself * has a restricted range, and &#123;@code fromElement&#125; or * &#123;@code toElement&#125; lies outside the bounds of the range. */NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive);/** * Returns a view of the portion of this set whose elements are less than * (or equal to, if &#123;@code inclusive&#125; is true) &#123;@code toElement&#125;. The * returned set is backed by this set, so changes in the returned set are * reflected in this set, and vice-versa. The returned set supports all * optional set operations that this set supports. * * &lt;p&gt;The returned set will throw an &#123;@code IllegalArgumentException&#125; * on an attempt to insert an element outside its range. * * @param toElement high endpoint of the returned set * @param inclusive &#123;@code true&#125; if the high endpoint * is to be included in the returned view * @return a view of the portion of this set whose elements are less than * (or equal to, if &#123;@code inclusive&#125; is true) &#123;@code toElement&#125; * @throws ClassCastException if &#123;@code toElement&#125; is not compatible * with this set&apos;s comparator (or, if the set has no comparator, * if &#123;@code toElement&#125; does not implement &#123;@link Comparable&#125;). * Implementations may, but are not required to, throw this * exception if &#123;@code toElement&#125; cannot be compared to elements * currently in the set. * @throws NullPointerException if &#123;@code toElement&#125; is null and * this set does not permit null elements * @throws IllegalArgumentException if this set itself has a * restricted range, and &#123;@code toElement&#125; lies outside the * bounds of the range */NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive);/** * Returns a view of the portion of this set whose elements are greater * than (or equal to, if &#123;@code inclusive&#125; is true) &#123;@code fromElement&#125;. * The returned set is backed by this set, so changes in the returned set * are reflected in this set, and vice-versa. The returned set supports * all optional set operations that this set supports. * * &lt;p&gt;The returned set will throw an &#123;@code IllegalArgumentException&#125; * on an attempt to insert an element outside its range. * * @param fromElement low endpoint of the returned set * @param inclusive &#123;@code true&#125; if the low endpoint * is to be included in the returned view * @return a view of the portion of this set whose elements are greater * than or equal to &#123;@code fromElement&#125; * @throws ClassCastException if &#123;@code fromElement&#125; is not compatible * with this set&apos;s comparator (or, if the set has no comparator, * if &#123;@code fromElement&#125; does not implement &#123;@link Comparable&#125;). * Implementations may, but are not required to, throw this * exception if &#123;@code fromElement&#125; cannot be compared to elements * currently in the set. * @throws NullPointerException if &#123;@code fromElement&#125; is null * and this set does not permit null elements * @throws IllegalArgumentException if this set itself has a * restricted range, and &#123;@code fromElement&#125; lies outside the * bounds of the range */NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive);]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- SortedSet -- (二十一)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F14%2F023-Collections-SortedSet.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 SortedSet 詳解 (十八)這一節主要學習集合框架中的 SortedSet 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ SortedSet 說明: All elements inserted into a sorted set must implement the Comparable interface SortedSet UML: SortedSet 源碼解析:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * Returns the comparator used to order the elements in this set, * 返回set中用於排列元素的比較器 * or &lt;tt&gt;null&lt;/tt&gt; if this set uses the &#123;@linkplain Comparable * 或者如果set用自然排序返回null * natural ordering&#125; of its elements. * * @return the comparator used to order the elements in this set, * or &lt;tt&gt;null&lt;/tt&gt; if this set uses the natural ordering * of its elements */Comparator&lt;? super E&gt; comparator();/** * Returns a view of the portion of this set whose elements range * 返回集合元素從fromElement包含到toElement不包含的一部分的視圖 * from &lt;tt&gt;fromElement&lt;/tt&gt;, inclusive, to &lt;tt&gt;toElement&lt;/tt&gt;, * exclusive. (If &lt;tt&gt;fromElement&lt;/tt&gt; and &lt;tt&gt;toElement&lt;/tt&gt; are * equal, the returned set is empty.) The returned set is backed * 如果fromElement與toElement相等，返回空set * by this set, so changes in the returned set are reflected in * 返回的set基於這個set，這個set中引用改變返回的set * this set, and vice-versa. The returned set supports all * 反之亦然 * optional set operations that this set supports. * 返回的set支持所有的set集合支持的操作 * * &lt;p&gt;The returned set will throw an &lt;tt&gt;IllegalArgumentException&lt;/tt&gt; * 返回的集合會拋出一個異常在視圖添加超出範圍的元素時 * on an attempt to insert an element outside its range. * * @param fromElement low endpoint (inclusive) of the returned set * @param toElement high endpoint (exclusive) of the returned set * @return a view of the portion of this set whose elements range from * &lt;tt&gt;fromElement&lt;/tt&gt;, inclusive, to &lt;tt&gt;toElement&lt;/tt&gt;, exclusive * @throws ClassCastException if &lt;tt&gt;fromElement&lt;/tt&gt; and * &lt;tt&gt;toElement&lt;/tt&gt; cannot be compared to one another using this * set&apos;s comparator (or, if the set has no comparator, using * natural ordering). Implementations may, but are not required * to, throw this exception if &lt;tt&gt;fromElement&lt;/tt&gt; or * &lt;tt&gt;toElement&lt;/tt&gt; cannot be compared to elements currently in * the set. * @throws NullPointerException if &lt;tt&gt;fromElement&lt;/tt&gt; or * &lt;tt&gt;toElement&lt;/tt&gt; is null and this set does not permit null * elements * @throws IllegalArgumentException if &lt;tt&gt;fromElement&lt;/tt&gt; is * greater than &lt;tt&gt;toElement&lt;/tt&gt;; or if this set itself * has a restricted range, and &lt;tt&gt;fromElement&lt;/tt&gt; or * &lt;tt&gt;toElement&lt;/tt&gt; lies outside the bounds of the range */SortedSet&lt;E&gt; subSet(E fromElement, E toElement);/** * Returns a view of the portion of this set whose elements are * strictly less than &lt;tt&gt;toElement&lt;/tt&gt;. The returned set is * 嚴格小於 * backed by this set, so changes in the returned set are * reflected in this set, and vice-versa. The returned set * supports all optional set operations that this set supports. * * &lt;p&gt;The returned set will throw an &lt;tt&gt;IllegalArgumentException&lt;/tt&gt; * on an attempt to insert an element outside its range. * * @param toElement high endpoint (exclusive) of the returned set * @return a view of the portion of this set whose elements are strictly * less than &lt;tt&gt;toElement&lt;/tt&gt; * @throws ClassCastException if &lt;tt&gt;toElement&lt;/tt&gt; is not compatible * with this set&apos;s comparator (or, if the set has no comparator, * if &lt;tt&gt;toElement&lt;/tt&gt; does not implement &#123;@link Comparable&#125;). * Implementations may, but are not required to, throw this * exception if &lt;tt&gt;toElement&lt;/tt&gt; cannot be compared to elements * currently in the set. * @throws NullPointerException if &lt;tt&gt;toElement&lt;/tt&gt; is null and * this set does not permit null elements * @throws IllegalArgumentException if this set itself has a * restricted range, and &lt;tt&gt;toElement&lt;/tt&gt; lies outside the * bounds of the range */SortedSet&lt;E&gt; headSet(E toElement);/** * Returns a view of the portion of this set whose elements are * greater than or equal to &lt;tt&gt;fromElement&lt;/tt&gt;. The returned * 大於 * set is backed by this set, so changes in the returned set are * reflected in this set, and vice-versa. The returned set * supports all optional set operations that this set supports. * * &lt;p&gt;The returned set will throw an &lt;tt&gt;IllegalArgumentException&lt;/tt&gt; * on an attempt to insert an element outside its range. * * @param fromElement low endpoint (inclusive) of the returned set * @return a view of the portion of this set whose elements are greater * than or equal to &lt;tt&gt;fromElement&lt;/tt&gt; * @throws ClassCastException if &lt;tt&gt;fromElement&lt;/tt&gt; is not compatible * with this set&apos;s comparator (or, if the set has no comparator, * if &lt;tt&gt;fromElement&lt;/tt&gt; does not implement &#123;@link Comparable&#125;). * Implementations may, but are not required to, throw this * exception if &lt;tt&gt;fromElement&lt;/tt&gt; cannot be compared to elements * currently in the set. * @throws NullPointerException if &lt;tt&gt;fromElement&lt;/tt&gt; is null * and this set does not permit null elements * @throws IllegalArgumentException if this set itself has a * restricted range, and &lt;tt&gt;fromElement&lt;/tt&gt; lies outside the * bounds of the range */SortedSet&lt;E&gt; tailSet(E fromElement);/** * Returns the first (lowest) element currently in this set. * * @return the first (lowest) element currently in this set * @throws NoSuchElementException if this set is empty */E first();/** * Returns the last (highest) element currently in this set. * * @return the last (highest) element currently in this set * @throws NoSuchElementException if this set is empty */E last();]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- AbstractSet -- (二十)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F14%2F022-Collections-AbstractSet.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 AbstractSet 詳解 (十七)這一節主要學習集合框架中的 AbstractSet 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ AbstractSet 說明: 不重寫任何 AbstractCollection 類的方法，僅僅擴展 equals() 及 hashCode() 方法 AbstractSet UML: AbstractSet 源碼解析:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * Returns the hash code value for this set. The hash code of a set is * defined to be the sum of the hash codes of the elements in the set, * where the hash code of a &lt;tt&gt;null&lt;/tt&gt; element is defined to be zero. * This ensures that &lt;tt&gt;s1.equals(s2)&lt;/tt&gt; implies that * &lt;tt&gt;s1.hashCode()==s2.hashCode()&lt;/tt&gt; for any two sets &lt;tt&gt;s1&lt;/tt&gt; * and &lt;tt&gt;s2&lt;/tt&gt;, as required by the general contract of * &#123;@link Object#hashCode&#125;. * * &lt;p&gt;This implementation iterates over the set, calling the * &lt;tt&gt;hashCode&lt;/tt&gt; method on each element in the set, and adding up * the results. * * @return the hash code value for this set * @see Object#equals(Object) * @see java.util.Set#equals(Object) */public int hashCode() &#123; int h = 0; Iterator&lt;E&gt; i = iterator(); while (i.hasNext()) &#123; E obj = i.next(); if (obj != null) h += obj.hashCode(); &#125; return h;&#125; /** * Removes from this set all of its elements that are contained in the * specified collection (optional operation). If the specified * collection is also a set, this operation effectively modifies this * 有效 * set so that its value is the &lt;i&gt;asymmetric set difference&lt;/i&gt; of * 非對稱 * the two sets. * * &lt;p&gt;This implementation determines which is the smaller of this set * and the specified collection, by invoking the &lt;tt&gt;size&lt;/tt&gt; * method on each. If this set has fewer elements, then the * implementation iterates over this set, checking each element * returned by the iterator in turn to see if it is contained in * the specified collection. If it is so contained, it is removed * from this set with the iterator&apos;s &lt;tt&gt;remove&lt;/tt&gt; method. If * the specified collection has fewer elements, then the * implementation iterates over the specified collection, removing * from this set each element returned by the iterator, using this * set&apos;s &lt;tt&gt;remove&lt;/tt&gt; method. * * &lt;p&gt;Note that this implementation will throw an * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt; if the iterator returned by the * &lt;tt&gt;iterator&lt;/tt&gt; method does not implement the &lt;tt&gt;remove&lt;/tt&gt; method. * * @param c collection containing elements to be removed from this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set changed as a result of the call * @throws UnsupportedOperationException if the &lt;tt&gt;removeAll&lt;/tt&gt; operation * is not supported by this set * @throws ClassCastException if the class of an element of this set * is incompatible with the specified collection * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if this set contains a null element and the * specified collection does not permit null elements * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see #remove(Object) * @see #contains(Object) */public boolean removeAll( Collection&lt;?&gt; c) &#123; boolean modified = false; if (size() &gt; c.size()) &#123; for ( Iterator&lt;?&gt; i = c.iterator(); i.hasNext(); ) modified |= remove(i.next()); // 異或 ，更高的性能 ？ &#125; else &#123; for ( Iterator&lt;?&gt; i = iterator(); i.hasNext(); ) &#123; if (c.contains(i.next())) &#123; i.remove(); modified = true; &#125; &#125; &#125; return modified;&#125;]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- Set -- (十九)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F14%2F021-Collections-Set.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 Set 詳解 (十六)這一節主要學習集合框架中的 Set 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ Set 說明: A collection that contains no duplicate elements. Set UML: Set 源碼解析:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Returns an iterator over the elements in this set. The elements are * 返回遍歷集合元素的迭代器 * returned in no particular order (unless this set is an instance of some * 沒有特定順序的返回這些元素 * class that provides a guarantee). * 除非這個set是一個提供了維護的實現的類 * * @return an iterator over the elements in this set */Iterator&lt;E&gt; iterator();/** * Adds the specified element to this set if it is not already present * (optional operation). More formally, adds the specified element * &lt;tt&gt;e&lt;/tt&gt; to this set if the set contains no element &lt;tt&gt;e2&lt;/tt&gt; * such that * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;. In combination with the * 調用離開set不會改變並且返回false * restriction on constructors, this ensures that sets never contain * 附帶構造器限制組合 * duplicate elements. * 這保證集合永遠不會包含重複的元素 * * &lt;p&gt;The stipulation above does not imply that sets must accept all * 約定以上沒有壽命集合必須接受所有元素 * elements; sets may refuse to add any particular element, including * 集合可以拒絕添加任何特定元素 * &lt;tt&gt;null&lt;/tt&gt;, and throw an exception, as described in the * 包括null，拋出異常， 在規範中由Collection.add說明 * specification for &#123;@link java.util.Collection#add Collection.add&#125;. * Individual set implementations should clearly document any * 個別的集合實現應該明確文檔任何限制他們可包含的元素 * restrictions on the elements that they may contain. * * @param e element to be added to this set * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified * element * @throws UnsupportedOperationException if the &lt;tt&gt;add&lt;/tt&gt; operation * is not supported by this set * @throws ClassCastException if the class of the specified element * prevents it from being added to this set * @throws NullPointerException if the specified element is null and this * set does not permit null elements * @throws IllegalArgumentException if some property of the specified element * prevents it from being added to this set */boolean add(E e);]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- Stack -- (十八)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F14%2F020-Collections-Stack.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 Stack 詳解 (十五)這一節主要學習集合框架中的 Stack 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ Stack 說明: 同樣是線程安全的 synchronized 方法 實現 Stack UML: Stack 源碼解析:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * Pushes an item onto the top of this stack. This has exactly * the same effect as: * &lt;blockquote&gt;&lt;pre&gt; * addElement(item)&lt;/pre&gt;&lt;/blockquote&gt; * * @param item the item to be pushed onto this stack. * @return the &lt;code&gt;item&lt;/code&gt; argument. * @see java.util.Vector#addElement */public E push(E item) &#123; addElement(item); return item;&#125;/** * Removes the object at the top of this stack and returns that * object as the value of this function. * * @return The object at the top of this stack (the last item * of the &lt;tt&gt;Vector&lt;/tt&gt; object). * @throws EmptyStackException if this stack is empty. */public synchronized E pop() &#123; E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj;&#125;/** * Looks at the object at the top of this stack without removing it * from the stack. * * @return the object at the top of this stack (the last item * of the &lt;tt&gt;Vector&lt;/tt&gt; object). * @throws EmptyStackException if this stack is empty. */public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1);&#125;/** * Tests if this stack is empty. * * @return &lt;code&gt;true&lt;/code&gt; if and only if this stack contains * no items; &lt;code&gt;false&lt;/code&gt; otherwise. */public boolean empty() &#123; return size() == 0;&#125;/** * Returns the 1-based position where an object is on this stack. * If the object &lt;tt&gt;o&lt;/tt&gt; occurs as an item in this stack, this * method returns the distance from the top of the stack of the * occurrence nearest the top of the stack; the topmost item on the * stack is considered to be at distance &lt;tt&gt;1&lt;/tt&gt;. The &lt;tt&gt;equals&lt;/tt&gt; * method is used to compare &lt;tt&gt;o&lt;/tt&gt; to the * items in this stack. * * @param o the desired object. * @return the 1-based position from the top of the stack where * the object is located; the return value &lt;code&gt;-1&lt;/code&gt; * indicates that the object is not on the stack. */public synchronized int search(Object o) &#123; int i = lastIndexOf(o); if (i &gt;= 0) &#123; return size() - i; &#125; return -1;&#125;]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- Vector -- (十七)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F14%2F019-Collections-Vector.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 Vector 詳解 (十四)這一節主要學習集合框架中的 Vector 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ Vector 說明: The iterators returned by this class’s iterator and listIterator methods are fail-fastThe Enumerations returned by the elements method are not fail-fast.Vector is synchronized. If a thread-safe implementation is not needed, it is recommended to use ArrayList in place of Vector.線程安全通過 synchronized 方法 實現內部元素由數組維護123protected Object[] elementData; private class Itr implements Iterator&lt;E&gt; &#123; ... &#125;final class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ... &#125; Vector UML: Vector 源碼解析:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * Trims the capacity of this vector to be the vector&apos;s current * size. If the capacity of this vector is larger than its current * size, then the capacity is changed to equal the size by replacing * its internal data array, kept in the field &#123;@code elementData&#125;, * with a smaller one. An application can use this operation to * minimize the storage of a vector. */public synchronized void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (elementCount &lt; oldCapacity) &#123; elementData = java.util.Arrays.copyOf( elementData, elementCount); &#125;&#125;/** * Returns an enumeration of the components of this vector. The * returned &#123;@code Enumeration&#125; object will generate all items in * this vector. The first item generated is the item at index &#123;@code 0&#125;, * then the item at index &#123;@code 1&#125;, and so on. * * @return an enumeration of the components of this vector * @see java.util.Iterator */public Enumeration&lt;E&gt; elements() &#123; return new Enumeration&lt;E&gt;() &#123; int count = 0; public boolean hasMoreElements() &#123; return count &lt; elementCount; &#125; public E nextElement() &#123; synchronized (Vector.this) &#123; if (count &lt; elementCount) &#123; return elementData(count++); &#125; &#125; throw new NoSuchElementException(&quot;Vector Enumeration&quot;); &#125; &#125;;&#125;/** * Returns a view of the portion of this List between fromIndex, * inclusive, and toIndex, exclusive. (If fromIndex and toIndex are * equal, the returned List is empty.) The returned List is backed by this * List, so changes in the returned List are reflected in this List, and * vice-versa. The returned List supports all of the optional List * operations supported by this List. * * &lt;p&gt;This method eliminates the need for explicit range operations (of * the sort that commonly exist for arrays). Any operation that expects * a List can be used as a range operation by operating on a subList view * instead of a whole List. For example, the following idiom * removes a range of elements from a List: * &lt;pre&gt; * list.subList(from, to).clear(); * &lt;/pre&gt; * Similar idioms may be constructed for indexOf and lastIndexOf, * and all of the algorithms in the Collections class can be applied to * a subList. * * &lt;p&gt;The semantics of the List returned by this method become undefined if * the backing list (i.e., this List) is &lt;i&gt;structurally modified&lt;/i&gt; in * any way other than via the returned List. (Structural modifications are * those that change the size of the List, or otherwise perturb it in such * a fashion that iterations in progress may yield incorrect results.) * * @param fromIndex low endpoint (inclusive) of the subList * @param toIndex high endpoint (exclusive) of the subList * @return a view of the specified range within this List * @throws IndexOutOfBoundsException if an endpoint index value is out of range * &#123;@code (fromIndex &lt; 0 || toIndex &gt; size)&#125; * @throws IllegalArgumentException if the endpoint indices are out of order * &#123;@code (fromIndex &gt; toIndex)&#125; */public synchronized List&lt;E&gt; subList( int fromIndex, int toIndex) &#123; return Collections.synchronizedList(super.subList(fromIndex, toIndex), this);&#125;]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- LinkedList -- (十六)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F14%2F018-Collections-LinkedList.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 LinkedList 詳解 (十三)由於LinkedList引用了Deque,先學習了Queue接口相關，現在回來學習LinkedList這一節主要學習集合框架中的 LinkedList 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ LinkedList 說明: Note that this implementation is not synchronized.迭代器 fail-fast內部類123private static class Node&lt;E&gt; &#123; ... &#125;private class ListItr implements ListIterator&lt;E&gt; &#123; ... &#125;private class DescendingIterator implements Iterator&lt;E&gt; &#123; ... &#125; LinkedList UML: LinkedList 源碼解析:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216 /** * Links e as first element. */ private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; // 前驅插入 size++; modCount++; &#125; /** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &#123;@code i&#125; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. * * @param o element to search for * @return the index of the first occurrence of the specified element in * this list, or -1 if this list does not contain the element */ public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125; /** * Removes the first occurrence of the specified element from this list, * if it is present. If this list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &#123;@code i&#125; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &#123;@code true&#125; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &#123;@code true&#125; if this list contained the specified element */ public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125; // 添加刪除內部操作 /** * Links e as first element. */ private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++; &#125; /** * Links e as last element. */ void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; /** * Inserts element e before non-null Node succ. */ void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; &#125; /** * Unlinks non-null first node f. */ private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element; &#125; /** * Unlinks non-null last node l. */ private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element; &#125; /** * Unlinks non-null node x. */ E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; // Deque operations /** * Inserts the specified element at the front of this list. * * @param e the element to insert * @return &#123;@code true&#125; (as specified by &#123;@link java.util.Deque#offerFirst&#125;) * @since 1.6 */ public boolean offerFirst(E e) &#123; addFirst(e); return true; &#125; /** * Inserts the specified element at the end of this list. * * @param e the element to insert * @return &#123;@code true&#125; (as specified by &#123;@link Deque#offerLast&#125;) * @since 1.6 */ public boolean offerLast(E e) &#123; addLast(e); return true; &#125;]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- LinkedBlockingDeque -- (十五)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F11%2FCollections-LinkedBlockingDeque.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 LinkedBlockingDeque 詳解 (十二)由於LinkedList引用了Deque,所以這一節先學習Queue接口相關，本實現類使用了JUC下的ReentrantLock鎖類，該類在學習鎖時詳細學習這一節主要學習集合框架中的 LinkedBlockingDeque 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ LinkedBlockingDeque 說明: 三個內部類1234static final class Node&lt;E&gt; &#123; ... &#125; // 雙向列表節點private abstract class AbstractItr implements Iterator&lt;E&gt; &#123; ... &#125; // 迭代器抽象類private class Itr extends AbstractItr &#123; ... &#125; // 升序private class DescendingItr extends AbstractItr &#123; .. &#125; // 降序 線程安全的實現方式123final ReentrantLock lock = new ReentrantLock();private final Condition notEmpty = lock.newCondition();private final Condition notFull = lock.newCondition(); LinkedBlockingDeque UML: LinkedBlockingDeque 源碼解析:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242 /** Doubly-linked list node class */ /** 雙端鏈錶節點類 */ static final class Node&lt;E&gt; &#123; /** * The item, or null if this node has been removed. * 條目，如果已經刪除，則為null */ E item; /** * One of: * - the real predecessor Node * - 真實的前任節點 * - this Node, meaning the predecessor is tail * - 這個節點，意味著前任為結尾 * - null, meaning there is no predecessor * - null，意味著沒有前任 */ Node&lt;E&gt; prev; /** * One of: * - the real successor Node * - 真實的後繼 * - this Node, meaning the successor is head * - 節點，意味著後繼為頭 * - null, meaning there is no successor * - null,意味著沒有後繼 */ Node&lt;E&gt; next; Node(E x) &#123; item = x; &#125; &#125; /** Main lock guarding all access */ /** 所有存儲訪問的主要守護鎖 */ final ReentrantLock lock = new ReentrantLock(); /** Condition for waiting takes 等待取出條件 */ private final Condition notEmpty = lock.newCondition(); /** Condition for waiting puts 等待放置條件 */ private final Condition notFull = lock.newCondition(); /** * Creates a &#123;@code LinkedBlockingDeque&#125; with a capacity of * &#123;@link Integer#MAX_VALUE&#125;, initially containing the elements of * the given collection, added in traversal order of the * collection&apos;s iterator. * 按照添加的集合迭代遍歷順序 * * @param c the collection of elements to initially contain * @throws NullPointerException if the specified collection or any * of its elements are null * 如果指定的集合或者他的任意元素為null，拋出異常 */ public LinkedBlockingDeque( Collection&lt;? extends E&gt; c) &#123; this(Integer.MAX_VALUE); final ReentrantLock lock = this.lock; lock.lock(); // Never contended, but necessary for visibility try &#123; for (E e : c) &#123; if (e == null) throw new NullPointerException(); if (!linkLast(new Node&lt;E&gt;(e))) throw new IllegalStateException(&quot;Deque full&quot;); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; /** * Returns the number of additional elements that this deque can ideally * 返回隊列理想情況無阻賽訪問的元素的數量 * (in the absence of memory or resource constraints) accept without * (在內存不足或資源) * blocking. This is always equal to the initial capacity of this deque * less the current &#123;@code size&#125; of this deque. * * &lt;p&gt;Note that you &lt;em&gt;cannot&lt;/em&gt; always tell if an attempt to insert * an element will succeed by inspecting &#123;@code remainingCapacity&#125; * because it may be the case that another thread is about to * insert or remove an element. */ public int remainingCapacity() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return capacity - count; &#125; finally &#123; lock.unlock(); &#125; &#125; /** * Returns an array containing all of the elements in this deque, in * proper sequence; the runtime type of the returned array is that of * the specified array. If the deque fits in the specified array, it * is returned therein. Otherwise, a new array is allocated with the * runtime type of the specified array and the size of this deque. * * &lt;p&gt;If this deque fits in the specified array with room to spare * (i.e., the array has more elements than this deque), the element in * the array immediately following the end of the deque is set to * &#123;@code null&#125;. * * &lt;p&gt;Like the &#123;@link #toArray()&#125; method, this method acts as bridge between * array-based and collection-based APIs. Further, this method allows * precise control over the runtime type of the output array, and may, * 精確 * under certain circumstances, be used to save allocation costs. * 情況 * * &lt;p&gt;Suppose &#123;@code x&#125; is a deque known to contain only strings. * The following code can be used to dump the deque into a newly * allocated array of &#123;@code String&#125;: * * &lt;pre&gt; * String[] y = x.toArray(new String[0]);&lt;/pre&gt; * * Note that &#123;@code toArray(new Object[0])&#125; is identical in function to * &#123;@code toArray()&#125;. * * @param a the array into which the elements of the deque are to * be stored, if it is big enough; otherwise, a new array of the * same runtime type is allocated for this purpose * @return an array containing all of the elements in this deque * @throws ArrayStoreException if the runtime type of the specified array * is not a supertype of the runtime type of every element in * this deque * @throws NullPointerException if the specified array is null */ @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T[] toArray(T[] a) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; if (a.length &lt; count) a = (T[])java.lang.reflect.Array.newInstance (a.getClass().getComponentType(), count); int k = 0; for (Node&lt;E&gt; p = first; p != null; p = p.next) a[k++] = (T)p.item; if (a.length &gt; k) a[k] = null; return a; &#125; finally &#123; lock.unlock(); &#125; &#125;// 插入刪除主要操作 // Basic linking and unlinking operations, called only while holding lock /** * Links node as first element, or returns false if full. */ private boolean linkFirst(Node&lt;E&gt; node) &#123; // assert lock.isHeldByCurrentThread(); if (count &gt;= capacity) return false; Node&lt;E&gt; f = first; node.next = f; first = node; if (last == null) last = node; else f.prev = node; ++count; notEmpty.signal(); return true; &#125; /** * Links node as last element, or returns false if full. * 連邊節點最後一個元素，或者如果full返回false */ private boolean linkLast(Node&lt;E&gt; node) &#123; // assert lock.isHeldByCurrentThread(); if (count &gt;= capacity) return false; Node&lt;E&gt; l = last; node.prev = l; last = node; if (first == null) first = node; else l.next = node; ++count; notEmpty.signal(); return true; &#125; /** * Removes and returns first element, or null if empty. */ private E unlinkFirst() &#123; // assert lock.isHeldByCurrentThread(); Node&lt;E&gt; f = first; if (f == null) return null; Node&lt;E&gt; n = f.next; E item = f.item; f.item = null; f.next = f; // help GC first = n; if (n == null) last = null; else n.prev = null; --count; notFull.signal(); return item; &#125; /** * Removes and returns last element, or null if empty. */ private E unlinkLast() &#123; // assert lock.isHeldByCurrentThread(); Node&lt;E&gt; l = last; if (l == null) return null; Node&lt;E&gt; p = l.prev; E item = l.item; l.item = null; l.prev = l; // help GC last = p; if (p == null) first = null; else p.next = null; --count; notFull.signal(); return item; &#125;]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- AbstractQueue -- (十四)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F11%2FCollections-AbstractQueue.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 AbstractQueue 詳解 (十一)由於LinkedList引用了Deque,所以這一節先學習Queue接口相關這一節主要學習集合框架中的 AbstractQueue 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ AbstractQueue 說明:AbstractQueue UML: AbstractQueue 源碼解析:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * Inserts the specified element into this queue if it is possible to do so * immediately without violating capacity restrictions, returning * &lt;tt&gt;true&lt;/tt&gt; upon success and throwing an &lt;tt&gt;IllegalStateException&lt;/tt&gt; * if no space is currently available. * * &lt;p&gt;This implementation returns &lt;tt&gt;true&lt;/tt&gt; if &lt;tt&gt;offer&lt;/tt&gt; succeeds, * 如果offer操作成功，這個實現返回true，否則拋出一個異常 * else throws an &lt;tt&gt;IllegalStateException&lt;/tt&gt;. * * @param e the element to add * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link java.util.Collection#add&#125;) * @throws IllegalStateException if the element cannot be added at this * time due to capacity restrictions * @throws ClassCastException if the class of the specified element * prevents it from being added to this queue * @throws NullPointerException if the specified element is null and * this queue does not permit null elements * @throws IllegalArgumentException if some property of this element * prevents it from being added to this queue */public boolean add(E e) &#123; if (offer(e)) return true; else throw new IllegalStateException(&quot;Queue full&quot;);&#125;/** * Adds all of the elements in the specified collection to this * queue. Attempts to addAll of a queue to itself result in * 視圖在一個隊列中添加自身會拋出一個異常 * &lt;tt&gt;IllegalArgumentException&lt;/tt&gt;. Further, the behavior of * this operation is undefined if the specified collection is * modified while the operation is in progress. * * &lt;p&gt;This implementation iterates over the specified collection, * and adds each element returned by the iterator to this * queue, in turn. A runtime exception encountered while * 一個運行時異常發生當嘗試添加一個元素 * trying to add an element (including, in particular, a * 特定的 * &lt;tt&gt;null&lt;/tt&gt; element) may result in only some of the elements * 元素導致僅僅相同的元素成功添加當關聯的異常拋出的時候 * having been successfully added when the associated exception is * thrown. * * @param c collection containing elements to be added to this queue * @return &lt;tt&gt;true&lt;/tt&gt; if this queue changed as a result of the call * @throws ClassCastException if the class of an element of the specified * collection prevents it from being added to this queue * @throws NullPointerException if the specified collection contains a * null element and this queue does not permit null elements, * or if the specified collection is null * @throws IllegalArgumentException if some property of an element of the * specified collection prevents it from being added to this * queue, or if the specified collection is this queue * @throws IllegalStateException if not all the elements can be added at * this time due to insertion restrictions * @see #add(Object) */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; if (c == null) throw new NullPointerException(); if (c == this) throw new IllegalArgumentException(); boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified;&#125;]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- BlockingDuque -- (十三)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F11%2FCollections-BlockingDuque.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 BlockingDuque 詳解 (十)由於LinkedList引用了Deque,所以這一節先學習Queue接口相關這一節主要學習集合框架中的 BlockingDuque 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ BlockingDuque 說明: Like any BlockingQueue, a BlockingDeque is thread safe BlockingDuque UML: BlockingDuque 源碼解析:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * Inserts the specified element at the front of this deque, * waiting if necessary for space to become available. * 必須等待空間成為可用 * * @param e the element to add * @throws InterruptedException if interrupted while waiting * @throws ClassCastException if the class of the specified element * prevents it from being added to this deque * @throws NullPointerException if the specified element is null * @throws IllegalArgumentException if some property of the specified * element prevents it from being added to this deque */void putFirst(E e) throws InterruptedException;/** * Inserts the specified element at the front of this deque, * waiting up to the specified wait time if necessary for space to * become available. * * @param e the element to add * @param timeout how long to wait before giving up, in units of * 放棄前等待的時間 * &lt;tt&gt;unit&lt;/tt&gt; * 單位時間 * @param unit a &lt;tt&gt;TimeUnit&lt;/tt&gt; determining how to interpret the * &lt;tt&gt;timeout&lt;/tt&gt; parameter * @return &lt;tt&gt;true&lt;/tt&gt; if successful, or &lt;tt&gt;false&lt;/tt&gt; if * the specified waiting time elapses before space is available * @throws InterruptedException if interrupted while waiting * @throws ClassCastException if the class of the specified element * prevents it from being added to this deque * @throws NullPointerException if the specified element is null * @throws IllegalArgumentException if some property of the specified * element prevents it from being added to this deque */boolean offerFirst(E e, long timeout, TimeUnit unit) throws InterruptedException;/** * Inserts the specified element into the queue represented by this deque * 意味著 * (in other words, at the tail of this deque) if it is possible to do so * immediately without violating capacity restrictions, returning * &lt;tt&gt;true&lt;/tt&gt; upon success and throwing an * &lt;tt&gt;IllegalStateException&lt;/tt&gt; if no space is currently available. * When using a capacity-restricted deque, it is generally preferable to * use &#123;@link #offer(Object) offer&#125;. * * &lt;p&gt;This method is equivalent to &#123;@link #addLast(Object) addLast&#125;. * * @param e the element to add * @throws IllegalStateException &#123;@inheritDoc&#125; * @throws ClassCastException if the class of the specified element * prevents it from being added to this deque * @throws NullPointerException if the specified element is null * @throws IllegalArgumentException if some property of the specified * element prevents it from being added to this deque */boolean add(E e);/** * Pushes an element onto the stack represented by this deque. In other * 意味著 * words, inserts the element at the front of this deque unless it would * 除非 * violate capacity restrictions. * * &lt;p&gt;This method is equivalent to &#123;@link #addFirst(Object) addFirst&#125;. * * @throws IllegalStateException &#123;@inheritDoc&#125; * @throws ClassCastException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified element is null * @throws IllegalArgumentException &#123;@inheritDoc&#125; */void push(E e);]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- Deque -- (十二)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F10%2FCollections-Deque.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 Deque 詳解 (九)由於LinkedList引用了Deque,所以這一節先學習Queue接口相關這一節主要學習集合框架中的 Deque 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ Deque 說明:Deque UML: Deque 源碼解析:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274/** * Inserts the specified element at the front of this deque if it is * 插入指定的元素在deque的前驅 * possible to do so immediately without violating capacity restrictions. * 如果沒有違反容量限制會理解插入 * When using a capacity-restricted deque, it is generally preferable to * 當使用有限容量的deque, * use method &#123;@link #offerFirst&#125;. * 一般更喜歡使用offerFirst方法 * * @param e the element to add * @throws IllegalStateException if the element cannot be added at this * time due to capacity restrictions * @throws ClassCastException if the class of the specified element * prevents it from being added to this deque * @throws NullPointerException if the specified element is null and this * deque does not permit null elements * @throws IllegalArgumentException if some property of the specified * element prevents it from being added to this deque */void addFirst(E e);/** * Inserts the specified element at the front of this deque if it is * 插入指定的元素在deque的前驅 * possible to do so immediately without violating capacity restrictions. * 如果沒有違反容量限制會理解插入 * When using a capacity-restricted deque, it is generally preferable to * 當使用有限容量的deque, * use method &#123;@link #offerFirst&#125;. * 一般更喜歡使用offerFirst方法 * * @param e the element to add * @throws IllegalStateException if the element cannot be added at this * time due to capacity restrictions * @throws ClassCastException if the class of the specified element * prevents it from being added to this deque * @throws NullPointerException if the specified element is null and this * deque does not permit null elements * @throws IllegalArgumentException if some property of the specified * element prevents it from being added to this deque */void addFirst(E e);/** * Inserts the specified element at the front of this deque unless it would * 插入一個指定的元素在deque的前驅 * violate capacity restrictions. When using a capacity-restricted deque, * 直到他違反了容量限制 * this method is generally preferable to the &#123;@link #addFirst&#125; method, * 當使用一個有限容量deque,這個方法通常比addFirst方法更好 * which can fail to insert an element only by throwing an exception. * 它能夠由拋出一個異常表示添加元素失敗 * * @param e the element to add * @return &lt;tt&gt;true&lt;/tt&gt; if the element was added to this deque, else * &lt;tt&gt;false&lt;/tt&gt; * @throws ClassCastException if the class of the specified element * prevents it from being added to this deque * 防止 * @throws NullPointerException if the specified element is null and this * deque does not permit null elements * @throws IllegalArgumentException if some property of the specified * element prevents it from being added to this deque */boolean offerFirst(E e);/** * Inserts the specified element at the end of this deque unless it would * 添加指定的元素在deque的末尾 * violate capacity restrictions. When using a capacity-restricted deque, * 直到違反容量限制 * this method is generally preferable to the &#123;@link #addLast&#125; method, * 當使用一個有限容量deque，這個方法通常是更優於addLast方法 * which can fail to insert an element only by throwing an exception. * * @param e the element to add * @return &lt;tt&gt;true&lt;/tt&gt; if the element was added to this deque, else * &lt;tt&gt;false&lt;/tt&gt; * @throws ClassCastException if the class of the specified element * prevents it from being added to this deque * @throws NullPointerException if the specified element is null and this * deque does not permit null elements * @throws IllegalArgumentException if some property of the specified * element prevents it from being added to this deque */boolean offerLast(E e);/** * Retrieves and removes the first element of this deque. This method * 檢查和移除deque的首元素 * differs from &#123;@link #pollFirst pollFirst&#125; only in that it throws an * 這個方法與pollFirst方法不同之處僅僅在於如果deque是一個empty他會拋出一個異常 * exception if this deque is empty. * * @return the head of this deque * @throws NoSuchElementException if this deque is empty */E removeFirst();/** * Retrieves and removes the first element of this deque, * 檢查和移除隊列中的首元素 * or returns &lt;tt&gt;null&lt;/tt&gt; if this deque is empty. * 如果隊列為空，返回null * * @return the head of this deque, or &lt;tt&gt;null&lt;/tt&gt; if this deque is empty */E pollFirst();/** * Retrieves, but does not remove, the first element of this deque. * 檢查，但不移除隊列中的首元素 * This method differs from &#123;@link #peekFirst peekFirst&#125; only in that it * 與peekFirst方法不同之處僅僅為當隊列為空，拋出一個異常 * throws an exception if this deque is empty. * * @return the head of this deque * @throws NoSuchElementException if this deque is empty */E getFirst();/** * Retrieves, but does not remove, the first element of this deque, * or returns &lt;tt&gt;null&lt;/tt&gt; if this deque is empty. * 如果隊列為空，返回null * * @return the head of this deque, or &lt;tt&gt;null&lt;/tt&gt; if this deque is empty */E peekFirst();/** * Removes the first occurrence of the specified element from this deque. * 移除隊列中第一個發現的指定元素 * If the deque does not contain the element, it is unchanged. * 如果隊列中不包含這個元素,隊列不會改變 * More formally, removes the first element &lt;tt&gt;e&lt;/tt&gt; such that * 更嚴格的講，移除第一個元素e * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt; * 當(o == null ? e == null : e.equals(e)) * (if such an element exists). * 如果這樣的元素存在 * Returns &lt;tt&gt;true&lt;/tt&gt; if this deque contained the specified element * 如果隊列包含了指定元素，返回true * (or equivalently, if this deque changed as a result of the call). * 與之相應的，作為調用的結果對聯改變了。 * * @param o element to be removed from this deque, if present * @return &lt;tt&gt;true&lt;/tt&gt; if an element was removed as a result of this call * @throws ClassCastException if the class of the specified element * is incompatible with this deque * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if the specified element is null and this * deque does not permit null elements * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) */boolean removeFirstOccurrence(Object o); /** * Inserts the specified element into the queue represented by this deque * 添加指定的元素到隊列中意味著如果沒有違反容量限制，他會立即執行 * (in other words, at the tail of this deque) if it is possible to do so * immediately without violating capacity restrictions, returning * &lt;tt&gt;true&lt;/tt&gt; upon success and throwing an * 成功返回true * &lt;tt&gt;IllegalStateException&lt;/tt&gt; if no space is currently available. * 如果當前沒有可用空間會拋出一個異常 * When using a capacity-restricted deque, it is generally preferable to * 當使用一個有限隊列，通常更好的做法是使用offer方法 * use &#123;@link #offer(Object) offer&#125;. * * &lt;p&gt;This method is equivalent to &#123;@link #addLast&#125;. * 這個方法等效于addLast方法 * * @param e the element to add * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link java.util.Collection#add&#125;) * @throws IllegalStateException if the element cannot be added at this * time due to capacity restrictions * @throws ClassCastException if the class of the specified element * prevents it from being added to this deque * @throws NullPointerException if the specified element is null and this * deque does not permit null elements * @throws IllegalArgumentException if some property of the specified * element prevents it from being added to this deque */ boolean add(E e); /** * Inserts the specified element into the queue represented by this deque * (in other words, at the tail of this deque) if it is possible to do so * immediately without violating capacity restrictions, returning * &lt;tt&gt;true&lt;/tt&gt; upon success and &lt;tt&gt;false&lt;/tt&gt; if no space is currently * 如果沒有可用空間，返回false * available. When using a capacity-restricted deque, this method is * generally preferable to the &#123;@link #add&#125; method, which can fail to * insert an element only by throwing an exception. * 僅僅由拋出一個異常表示添加元素失敗 * * &lt;p&gt;This method is equivalent to &#123;@link #offerLast&#125;. * * @param e the element to add * @return &lt;tt&gt;true&lt;/tt&gt; if the element was added to this deque, else * &lt;tt&gt;false&lt;/tt&gt; * @throws ClassCastException if the class of the specified element * prevents it from being added to this deque * @throws NullPointerException if the specified element is null and this * deque does not permit null elements * @throws IllegalArgumentException if some property of the specified * element prevents it from being added to this deque */ boolean offer(E e); /** * Retrieves, but does not remove, the head of the queue represented by * 檢查，但不移除 * this deque (in other words, the first element of this deque). * This method differs from &#123;@link #peek peek&#125; only in that it throws an * exception if this deque is empty. * * &lt;p&gt;This method is equivalent to &#123;@link #getFirst()&#125;. * * @return the head of the queue represented by this deque * @throws NoSuchElementException if this deque is empty */ E element(); /** * Retrieves, but does not remove, the head of the queue represented by * this deque (in other words, the first element of this deque), or * returns &lt;tt&gt;null&lt;/tt&gt; if this deque is empty. * * &lt;p&gt;This method is equivalent to &#123;@link #peekFirst()&#125;. * * @return the head of the queue represented by this deque, or * &lt;tt&gt;null&lt;/tt&gt; if this deque is empty */ E peek(); /** * Pushes an element onto the stack represented by this deque (in other * 壓入一個元到棧中意味著這個隊列如果沒有違反容量限制會立即執行 * words, at the head of this deque) if it is possible to do so * immediately without violating capacity restrictions, returning * &lt;tt&gt;true&lt;/tt&gt; upon success and throwing an * 成功返回true * &lt;tt&gt;IllegalStateException&lt;/tt&gt; if no space is currently available. * 如果滅有可用空間拋出一個異常 * * &lt;p&gt;This method is equivalent to &#123;@link #addFirst&#125;. * * @param e the element to push * @throws IllegalStateException if the element cannot be added at this * time due to capacity restrictions * @throws ClassCastException if the class of the specified element * prevents it from being added to this deque * @throws NullPointerException if the specified element is null and this * deque does not permit null elements * @throws IllegalArgumentException if some property of the specified * element prevents it from being added to this deque */ void push(E e); /** * Returns an iterator over the elements in this deque in reverse * 相反 * sequential order. The elements will be returned in order from * 的序列順序 * last (tail) to first (head). * 從尾到頭 * * @return an iterator over the elements in this deque in reverse * sequence */ Iterator&lt;E&gt; descendingIterator();]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- BlockingQueue -- (十一)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F10%2FCollections-BlockingQueue.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 BlockingQueue 詳解 (八)由於LinkedList引用了Deque,所以這一節先學習Queue接口相關這一節主要學習集合框架中的 BlockingQueue 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ BlockingQueue 說明: BlockingQueue implementations are thread-safe 線程安全的 Throws exception Special value Blocks Times out Insert add(e) offer(e) put(e) offer(e, time, unit) Remove remove() poll() take() poll(time, unit) Examine element() peek() not applicable not applicable BlockingQueue UML: BlockingQueue 源碼解析:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Removes all available elements from this queue and adds them * 移除所有可用的元素從隊列中，并添加他們到給定的集合中 * to the given collection. This operation may be more * efficient than repeatedly polling this queue. A failure * 這個操作比起重複的poll這個隊列更加高效 * encountered while attempting to add elements to * 當試圖添加元素到集合中遇到一個失敗 * collection &lt;tt&gt;c&lt;/tt&gt; may result in elements being in neither, * 當關聯的異常拋出來任意一個或者二者，三者在元素中 * either or both collections when the associated exception is * thrown. Attempts to drain a queue to itself result in * 試圖排除一個隊列自己的結果會發生異常 * &lt;tt&gt;IllegalArgumentException&lt;/tt&gt;. Further, the behavior of * this operation is undefined if the specified collection is * 這個操作的行為是未定義的，如果指定的集合在操作過程改變了 * modified while the operation is in progress. * * @param c the collection to transfer elements into * @return the number of elements transferred * @throws UnsupportedOperationException if addition of elements * is not supported by the specified collection * @throws ClassCastException if the class of an element of this queue * prevents it from being added to the specified collection * @throws NullPointerException if the specified collection is null * @throws IllegalArgumentException if the specified collection is this * queue, or some property of an element of this queue prevents * it from being added to the specified collection */int drainTo(Collection&lt;? super E&gt; c);/** * Removes all available elements from this queue and adds them * 移除所有可用的元素從隊列中，并添加他們到給定的集合中 * to the given collection. This operation may be more * efficient than repeatedly polling this queue. A failure * 這個操作比起重複的poll這個隊列更加高效 * encountered while attempting to add elements to * 當試圖添加元素到集合中遇到一個失敗 * collection &lt;tt&gt;c&lt;/tt&gt; may result in elements being in neither, * 當關聯的異常拋出來任意一個或者二者，三者在元素中 * either or both collections when the associated exception is * thrown. Attempts to drain a queue to itself result in * 試圖排除一個隊列自己的結果會發生異常 * &lt;tt&gt;IllegalArgumentException&lt;/tt&gt;. Further, the behavior of * this operation is undefined if the specified collection is * 這個操作的行為是未定義的，如果指定的集合在操作過程改變了 * modified while the operation is in progress. * * @param c the collection to transfer elements into * @return the number of elements transferred * @throws UnsupportedOperationException if addition of elements * is not supported by the specified collection * @throws ClassCastException if the class of an element of this queue * prevents it from being added to the specified collection * @throws NullPointerException if the specified collection is null * @throws IllegalArgumentException if the specified collection is this * queue, or some property of an element of this queue prevents * it from being added to the specified collection */int drainTo(Collection&lt;? super E&gt; c);]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- Queue -- (十)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F10%2FCollections-Queue.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 Queue 詳解 (七)由於LinkedList引用了Deque,所以這一節先學習Queue接口相關這一節主要學習集合框架中的 Queue 成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ Queue 接口Queue 類 UML: 實現類源碼解析:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Inserts the specified element into this queue if it is possible to do * so immediately without violating capacity restrictions. * When using a capacity-restricted queue, this method is generally * 當使用容量受限的隊列， * preferable to &#123;@link #add&#125;, which can fail to insert an element only * 這個方法是通常最好比使用add, 他可以錯誤的添加一個元素僅僅由拋出的異常 * by throwing an exception. * * @param e the element to add * @return &lt;tt&gt;true&lt;/tt&gt; if the element was added to this queue, else * &lt;tt&gt;false&lt;/tt&gt; * @throws ClassCastException if the class of the specified element * prevents it from being added to this queue * @throws NullPointerException if the specified element is null and * this queue does not permit null elements * @throws IllegalArgumentException if some property of this element * prevents it from being added to this queue */boolean offer(E e);/** * Retrieves and removes the head of this queue. This method differs * 檢索 * from &#123;@link #poll poll&#125; only in that it throws an exception if this * 這個方法與poll不同的地方僅僅在隊列為空時拋出一個異常 * queue is empty. * * @return the head of this queue * @throws java.util.NoSuchElementException if this queue is empty */E remove();/** * Retrieves and removes the head of this queue, * or returns &lt;tt&gt;null&lt;/tt&gt; if this queue is empty. * 如果隊列為null返回null * * @return the head of this queue, or &lt;tt&gt;null&lt;/tt&gt; if this queue is empty */E poll();/** * Retrieves, but does not remove, the head of this queue. This method * 檢索, 但不刪除, * differs from &#123;@link #peek peek&#125; only in that it throws an exception * 這個方法與peek的不同之處僅在 如果隊列為null拋出一個異常 * if this queue is empty. * * @return the head of this queue * @throws java.util.NoSuchElementException if this queue is empty */E element();/** * Retrieves, but does not remove, the head of this queue, * or returns &lt;tt&gt;null&lt;/tt&gt; if this queue is empty. * 如果隊列為null返回null * * @return the head of this queue, or &lt;tt&gt;null&lt;/tt&gt; if this queue is empty */E peek();]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- AbstractSequentialList -- (九)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F10%2FCollections-AbstractSequentialList.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 AbstractSequentialList 抽象類詳解 (六)這一節主要學習集合框架中的 AbstractSequentialList 抽象類的成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ AbstractSequentialList List接口抽象類 定義了最小化的一般通用的方法實現12345public E get(int index) &#123; ... &#125;public E set(int index, E element) &#123; ... &#125;public void add(int index, E element) &#123; ... &#125;public E remove(int index) &#123; ... &#125;public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; ... &#125; AbstractList類UML: 實現類源碼解析:1234567891011121314151617181920212223242526272829/** * Replaces the element at the specified position in this list with the * specified element (optional operation). * * &lt;p&gt;This implementation first gets a list iterator pointing to the * indexed element (with &lt;tt&gt;listIterator(index)&lt;/tt&gt;). Then, it gets * the current element using &lt;tt&gt;ListIterator.next&lt;/tt&gt; and replaces it * with &lt;tt&gt;ListIterator.set&lt;/tt&gt;. * * &lt;p&gt;Note that this implementation will throw an * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt; if the list iterator does not * implement the &lt;tt&gt;set&lt;/tt&gt; operation. * * @throws UnsupportedOperationException &#123;@inheritDoc&#125; * @throws ClassCastException &#123;@inheritDoc&#125; * @throws NullPointerException &#123;@inheritDoc&#125; * @throws IllegalArgumentException &#123;@inheritDoc&#125; * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; try &#123; ListIterator&lt;E&gt; e = listIterator(index); E oldVal = e.next(); e.set(element); return oldVal; // 返回的是舊值，被新值覆蓋 remove(index) 同樣返回的是舊值 &#125; catch (NoSuchElementException exc) &#123; throw new IndexOutOfBoundsException(&quot;Index: &quot;+index); &#125;&#125;]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- ArrayList -- (八)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F09%2FCollections-ArrayList.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 ArrayList 類詳解 (五)這一節主要學習集合框架中的ArrayList類的成員屬性、方法等具體實現存在遺留問題相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ ArrayList List接口具體類 底層實現:Object的數組1234567891011/** * The array buffer into which the elements of the ArrayList are stored. * 數組的緩存用於ArrayList存儲元素的空間 * The capacity of the ArrayList is the length of this array buffer. Any * ArrayList的容量是數組緩存的長度. * empty ArrayList with elementData == EMPTY_ELEMENTDATA will be expanded to * 任何空的ArrayList的 elementData == EMPTY_ELEMENTDATA 在第一個元素添加時 * DEFAULT_CAPACITY when the first element is added. * 擴大 10 容量 */private transient Object[] elementData; // 非序列化的 存在三個內部類:12345private class Itr implements Iterator&lt;E&gt; ; // 提供集合序列遍歷,移除最後一個元素操作private class ListItr extends Itr implements ListIterator&lt;E&gt; ; // 提供集合向前向後遍歷,set,add操作// 截取指定索引範圍的元素list，但是僅僅是多了一個引用副本，指向的還是元list的那段內存空間 // 子list中修改元素，元list相等索引位置的元素同樣被修改了private class SubList extends AbstractList&lt;E&gt; implements RandomAccess; 遺留問題 1、JAVA數組的定義、初始化、賦值的相關操作 【突然發現最基本的數組基本含義都有些搞不明白了，看完所有本類代碼后，查一下數組相關知識12345/** * Shared empty array instance used for empty instances. * 用於empty實例的共享的數組實例 */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; 2、數據串行化 IO操作，此操作相關在 JAVA IO中詳解12private void writeObject(java.io.ObjectOutputStream s)&#123; ... &#125;private void readObject(java.io.ObjectInputStream s)&#123; ... &#125; ArrayList類UML: 實現類源碼解析:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605/** * Default initial capacity. * 默認的初始容量 */private static final int DEFAULT_CAPACITY = 10;/** * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if * ArrayList實例的增加的容量, * necessary, to ensure that it can hold at least the number of elements * 如果必要, 確保容量可以容納指定的最小容量參數的元素個數 * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity * 期望的 最小容量 */public void ensureCapacity(int minCapacity) &#123; // 最小的擴容 int minExpand = (elementData != EMPTY_ELEMENTDATA) // any size if real element table ? 0 // larger than default for empty table. It&apos;s already supposed to be // at default size. : DEFAULT_CAPACITY; // 10 if (minCapacity &gt; minExpand) &#123; // 確定明確容量 ensureExplicitCapacity(minCapacity); &#125;&#125;// 明確內部容量private void ensureCapacityInternal(int minCapacity) &#123; // 判斷共享數據是否是一個空數組 if (elementData == EMPTY_ELEMENTDATA) &#123; // 如果是，設置最小容量，默認 10 ，指定的容量大於10時設為 // 指定的容量 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * The maximum size of array to allocate. * 分配的數組最大的值 * Some VMs reserve some header words in an array. * 一些vm在數組中保留了一些頭信息 * Attempts to allocate larger arrays may result in * 嘗試分配更大的數組結果會出現 OutOfMemoryError * OutOfMemoryError: Requested array size exceeds VM limit * 請求數組的元素超過了vm的極限 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * Increases the capacity to ensure that it can hold at least the * 增加容量確保容量能夠提供由最小容量參數指定的元素個數. * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity * 期望的 */private void grow(int minCaGpacity) &#123; // overflow-conscious code //====================================== 如果共享數組為空數組 int oldCapacity = elementData.length; // 0 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 0 if (newCapacity - minCapacity &lt; 0) // 一定為負數 newCapacity = minCapacity; // 新容量為 指定最小容量 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // 新容量與最大容量比較 newCapacity = hugeCapacity(minCapacity); // 設為最大容量:Integer.MAX_VALUE - 8; // minCapacity is usually close to size, so this is a win: // 數組拷貝 elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125;/** * Returns &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element. * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this list contains * at least one element &lt;tt&gt;e&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;. * * @param o element whose presence in this list is to be tested * 存在 * @return &lt;tt&gt;true&lt;/tt&gt; if this list contains the specified element */public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125;/** * Returns the index of the first occurrence of the specified element * 返回list中指定元素的首次范閒的索引 * in this list, or -1 if this list does not contain the element. * 或者不包含元素時返回-1 * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * 更正式的講， 返回 ( o == null ? get(i) == null : o.equals( get(i) ) ) * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * 最低的索引 * or -1 if there is no such index. * 如果沒有這樣的索引，返回-1 */public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; /** * Returns the index of the last occurrence of the specified element * 返回list中指定元素的最後發現的索引 * in this list, or -1 if this list does not contain the element. * More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. * 不存在這樣的索引返回-1 */public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;/** * Returns an array containing all of the elements in this list * 返回一個數組包含了所有list中的正確序列的元素 * in proper sequence (from first to last element). * * &lt;p&gt;The returned array will be &quot;safe&quot; in that no references to it are * 返回的數組是安全的，因為沒有引用維護這個list * maintained by this list. (In other words, this method must allocate * (換句話說,這個方法必須分配一個新的數組) * a new array). The caller is thus free to modify the returned array. * 調用者因而自由的改變返回的數組 * * &lt;p&gt;This method acts as bridge between array-based and collection-based * 這個方法的行為作為數組和集合基礎的橋樑 * APIs. * * @return an array containing all of the elements in this list in * proper sequence * 正確 */public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125;/** * Returns an array containing all of the elements in this list in proper * sequence (from first to last element); the runtime type of the returned * array is that of the specified array. If the list fits in the * 返回數組的運行時類型是這個指定數組的類型. * specified array, it is returned therein. Otherwise, a new array is * 在其中 否則， * allocated with the runtime type of the specified array and the size of * 一個新的數組又指定數組的運行時類型與list的大小分配 * this list. * * &lt;p&gt;If the list fits in the specified array with room to spare * (i.e., the array has more elements than the list), the element in * the array immediately following the end of the collection is set to * 立即 * &lt;tt&gt;null&lt;/tt&gt;. (This is useful in determining the length of the * 確定 * list &lt;i&gt;only&lt;/i&gt; if the caller knows that the list does not contain * any null elements.) * * @param a the array into which the elements of the list are to * be stored, if it is big enough; otherwise, a new array of the * same runtime type is allocated for this purpose. * @return an array containing the elements of the list * @throws ArrayStoreException if the runtime type of the specified array * is not a supertype of the runtime type of every element in * this list * @throws NullPointerException if the specified array is null */@SuppressWarnings(&quot;unchecked&quot;)public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a&apos;s runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a;&#125; /** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; // 範圍檢測，不會檢測 索引為負的情況,只會檢測索引是否超過size值 rangeCheck(index); return elementData(index);&#125; /** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; // 範圍檢測，不會檢測 索引為負的情況,只會檢測索引是否超過size值 rangeCheck(index); return elementData(index);&#125; /** * Replaces the element at the specified position in this list with * the specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * 返回設定值之前的舊值 * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125;/** * Inserts the specified element at the specified position in this * 在指定位置添加元素 * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * 隨後的元素向右移動(增加索引) * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! // 指定位置后的元素拷貝 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125;/** * Removes the element at the specified position in this list. * 移除list中指定位置的元素 * Shifts any subsequent elements to the left (subtracts one from their * 隨後的元素左移(索引減一) * indices). * * @param index the index of the element to be removed * 返回移除索引位置時的舊數據 * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) // 指定位置元素前移 System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;/** * Removes the first occurrence of the specified element from this list, * 移除list中指定的首次發現的元素 * if it is present. If the list does not contain the element, it is * 如果它存在的話 如果不包含這樣的元素，不發生改變 * unchanged. More formally, removes the element with the lowest index * 更正式的說，移除符合( o == null ? get(i) == null : o.equalse(get(i)) ) * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * 規則的最低索引的元素 * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * (如果這樣的元素存在) * contained the specified element (or equivalently, if this list * 如果list中包含指定元素返回true * changed as a result of the call). * (或者等效的,這個list因為這個方法的調用改變了結果) * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;/* * Private remove method that skips bounds checking and does not * 不做校驗的是快速刪除方法，不返回刪除的元素 * return the value removed. */private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125;/** * Appends all of the elements in the specified collection to the end of * 在list的末尾添加指定集合中的所有元素 * this list, in the order that they are returned by the * 按照集合迭代順序返回的順序 * specified collection&apos;s Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * 這個操作的行為是未定義的,如果當操作過程中指定的集合改變了 * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * (這就暗示了調用的行為當這個指定的集合是這個list，並且這個list是不為空時，是未定義的) * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount /** * * Integer[] des = new Integer[ 4 ]; * Integer[] src = &#123; 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 &#125;; * * // 把 src 數組的元素從 第 2 號位置開始拷貝,拷貝3個元素 * // 到 des 數組中，在des中的 1 號位置開始放置這些數據 * System.arraycopy( src, 2, des, 1, 3 ); * */ System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0;&#125;/** * Removes from this list all of the elements whose index is between * 從list中移除所有的索引在[fromIndex,toIndex)之間元素 * &#123;@code fromIndex&#125;, inclusive, and &#123;@code toIndex&#125;, exclusive. * Shifts any succeeding elements to the left (reduces their index). * This call shortens the list by &#123;@code (toIndex - fromIndex)&#125; elements. * (If &#123;@code toIndex==fromIndex&#125;, this operation has no effect.) * (如果fromIndex == toIndex，這個操作沒有任何影響) * * @throws IndexOutOfBoundsException if &#123;@code fromIndex&#125; or * &#123;@code toIndex&#125; is out of range * (&#123;@code fromIndex &lt; 0 || * fromIndex &gt;= size() || * toIndex &gt; size() || * toIndex &lt; fromIndex&#125;) */protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; // clear to let GC do its work &#125; size = newSize;&#125; /** * Removes from this list all of its elements that are contained in the * 從list中移除所有的包含于指定集合中的元素 * specified collection. * * @param c collection containing elements to be removed from this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see Collection#contains(Object) */public boolean removeAll(Collection&lt;?&gt; c) &#123; return batchRemove(c, false);&#125;/** * Removes from this list all of its elements that are contained in the * 從list中移除所有的包含于指定集合中的元素 * specified collection. * * @param c collection containing elements to be removed from this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws ClassCastException if the class of an element of this list * is incompatible with the specified collection * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;) * @throws NullPointerException if this list contains a null element and the * specified collection does not permit null elements * (&lt;a href=&quot;Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;), * or if the specified collection is null * @see Collection#contains(Object) */public boolean removeAll(Collection&lt;?&gt; c) &#123; return batchRemove(c, false);&#125;private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) // 判斷當前集合的元素是否包含在指定集合中 // 判斷當前集合的元素是否包含在指定集合中 // 如果不包含在其中 complement = false // 將此元素重新索引到數組中==即保留非指定的元素集，去除了包含的元素 // 如果包含在其中 complement = true // 將此元素重新索引到數組中==即保留指定的元素集，去除了非包含的元素 if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // 保留AbstractCollection的兼容性行為 // even if c.contains() throws. if (r != size) &#123; // 拷貝剩餘的未同指定集合比較的元素到新索引位置 System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; return modified;&#125; /** * Returns a list iterator over the elements in this list (in proper * 返回一個list中的遍歷元素的list迭代器 * sequence), starting at the specified position in the list. * 開始於指定的位置 * The specified index indicates the first element that would be * 指定的索引說明第一個元素由初始ListIterator.next調用返回 * returned by an initial call to &#123;@link ListIterator#next next&#125;. * An initial call to &#123;@link ListIterator#previous previous&#125; would * 初始調用ListIterator.previous調用用指定的索引減一的元素 * return the element with the specified index minus one. * * &lt;p&gt;The returned list iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) // 索引越界異常 throw new IndexOutOfBoundsException(&quot;Index: &quot;+index); // 新建一個指定索引開始的迭代器 return new ListItr(index);&#125;/** * Returns a list iterator over the elements in this list (in proper * sequence). * * &lt;p&gt;The returned list iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @see #listIterator(int) */public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0);&#125;/** * Returns an iterator over the elements in this list in proper sequence. * * &lt;p&gt;The returned iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;. * * @return an iterator over the elements in this list in proper sequence */public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125;/** * Returns a view of the portion of this list between the specified * 返回在[fromIndex,toIndex)之間的list的一部分視圖 * &#123;@code fromIndex&#125;, inclusive, and &#123;@code toIndex&#125;, exclusive. (If * &#123;@code fromIndex&#125; and &#123;@code toIndex&#125; are equal, the returned list is * (如果 fromIndex == toIndex ，返回list是empty的) * empty.) The returned list is backed by this list, so non-structural * 這個返回的list基於當前的list, * changes in the returned list are reflected in this list, and vice-versa. * 因此沒有結構改變在這個list中返回的list是課反射的,反之亦然 * The returned list supports all of the optional list operations. * 這個返回的list支持所有的list的可選操作 * * &lt;p&gt;This method eliminates the need for explicit range operations (of * 這個方法消除了明確範圍操作的需要 * the sort that commonly exist for arrays). Any operation that expects * (排序一般存在的數組) * a list can be used as a range operation by passing a subList view * 任何期望一個list用於範圍操作的操作通過一個子list視圖帶起整個list * instead of a whole list. For example, the following idiom * 例如，從list中移除一個範圍的元素 * removes a range of elements from a list: * 之後通常的做法: * &lt;pre&gt; * list.subList(from, to).clear(); * &lt;/pre&gt; * Similar idioms may be constructed for &#123;@link #indexOf(Object)&#125; and * 類似的做法能構造indexOf,lastIndexOf方法， * &#123;@link #lastIndexOf(Object)&#125;, and all of the algorithms in the * 並且所有的算法在Collections類中的都可以應用於子list. * &#123;@link Collections&#125; class can be applied to a subList. * * &lt;p&gt;The semantics of the list returned by this method become undefined if * 有這個方法返回的list的語意成為未定義的， * the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;/i&gt; in * 如果基於list的結構化的改變通過任何方式 * any way other than via the returned list. (Structural modifications are * 通過返回的list * those that change the size of this list, or otherwise perturb it in such * (結構化改變指的是那些改變list大小，或者除此之外的麻煩的，在迭代過程中正確結果產出的方法) * a fashion that iterations in progress may yield incorrect results.) * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws IllegalArgumentException &#123;@inheritDoc&#125; */public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex);&#125;]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- AbstractList -- (七)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F07%2FCollections-AbstractList.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 AbstractList 抽象類詳解 (四)這一節主要學習集合框架中的AbstractList抽象類的成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ AbstractList List接口抽象類 定義了最小化的一般通用的方法實現 1234567891011121314protected transient int modCount = 0; // fail-fast機制的實現：transient,如果擴展子類不需要此機制,modCount會ignore/** * 遺留問題：這裡為什麼使用 transient 關鍵字，而不是 volatile ？ * 如果是 volatile 關鍵字可以理解為內存可見，所以無亂那個線程修改了集合，那麼modCount都能感知到，與之比對的 expectedModCount * 都能發現值不同，因此發生 ConcurrentModificationException 異常。 * 但是為何使用 transient 呢？ 這個關鍵字不是與 序列化 相關嗎？ * 難道這裡 集合 迭代過程中 有 序列化 的相關操作？ * 暫時未想明白，遺留一下這個問題 * * * 回答上面的遺留問題,這個modCount只是感知結構化發生變化的次數(見API DOC) * 而這個次數,並不需要序列化操作,僅僅存在調用者內存中即可,應該是出於性能考慮 * 因此與 volatile 或者改變的內存值 沒有任何關係./(ㄒoㄒ)/~~ 我想多了,不是，是想彎路了 */ AbstractList抽象類包含方法: 實現類源碼解析:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518/** * Sole constructor. (For invocation by subclass constructors, typically * 唯一的構造器.(.隱含的有子類調用) * implicit.) */protected AbstractList() &#123;&#125;/** * Appends the specified element to the end of this list (optional * 添加指定元素到list的末尾，可選的操作 * operation). * * &lt;p&gt;Lists that support this operation may place limitations on what * 支持這個操作的list可以限制添加至這個list的的元素的放置地點 * elements may be added to this list. In particular, some * 特別說明， * lists will refuse to add null elements, and others will impose * 一些list會拒絕添加null元素， * restrictions on the type of elements that may be added. List * 而另一些list會加上添加至這個list的元素的類型限制. * classes should clearly specify in their documentation any restrictions * List類要在他們的文檔中明確添加至list的元素的限制條件的詳細說明 * on what elements may be added. * * &lt;p&gt;This implementation calls &#123;@code add(size(), e)&#125;. * 這個實現調用add(size(),e). * * &lt;p&gt;Note that this implementation throws an * 注意這個實現如果沒有複寫add(int,Object) * &#123;@code UnsupportedOperationException&#125; unless * add(int ,E)會拋出一個異常 UnsupportedOperationException * &#123;@link #add(int, Object) add(int, E)&#125; is overridden. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) * @throws UnsupportedOperationException if the &#123;@code add&#125; operation * is not supported by this list * @throws ClassCastException if the class of the specified element * prevents it from being added to this list * @throws NullPointerException if the specified element is null and this * list does not permit null elements * @throws IllegalArgumentException if some property of this element * prevents it from being added to this list */public boolean add(E e) &#123; add(size(), e); return true;&#125;/** * &#123;@inheritDoc&#125; * * &lt;p&gt;This implementation always throws an * 這個實現總是拋出異常 UnsupportedOperationException * &#123;@code UnsupportedOperationException&#125;. * * @throws UnsupportedOperationException &#123;@inheritDoc&#125; * @throws ClassCastException &#123;@inheritDoc&#125; * @throws NullPointerException &#123;@inheritDoc&#125; * @throws IllegalArgumentException &#123;@inheritDoc&#125; * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; throw new UnsupportedOperationException();&#125;/** * &#123;@inheritDoc&#125; * * &lt;p&gt;This implementation always throws an * &#123;@code UnsupportedOperationException&#125;. * * @throws UnsupportedOperationException &#123;@inheritDoc&#125; * @throws ClassCastException &#123;@inheritDoc&#125; * @throws NullPointerException &#123;@inheritDoc&#125; * @throws IllegalArgumentException &#123;@inheritDoc&#125; * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public void add(int index, E element) &#123; throw new UnsupportedOperationException();&#125;/** * &#123;@inheritDoc&#125; * * &lt;p&gt;This implementation always throws an * &#123;@code UnsupportedOperationException&#125;. * * @throws UnsupportedOperationException &#123;@inheritDoc&#125; * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; throw new UnsupportedOperationException();&#125;/** * &#123;@inheritDoc&#125; * * &lt;p&gt;This implementation first gets a list iterator (with * 這個實現首先獲取一個list迭代器(有listIterator獲得) * &#123;@code listIterator()&#125;). Then, it iterates over the list until the * 而後,由迭代器遍歷list直到發現指定的元素, * specified element is found or the end of the list is reached. * 或者list到達list的末尾. * * @throws ClassCastException &#123;@inheritDoc&#125; * @throws NullPointerException &#123;@inheritDoc&#125; */public int indexOf(Object o) &#123; //獲取listIterator雙向迭代器 ListIterator&lt;E&gt; it = listIterator(); if (o==null) &#123; // 指定元素為null while (it.hasNext()) // 遍歷本list if (it.next()==null) // 本list存在null元素 return it.previousIndex(); // 返回 此元素索引 &#125; else &#123; while (it.hasNext()) if (o.equals(it.next())) // 判斷指定元素與本list中的元素是否相等 return it.previousIndex(); &#125; return -1;&#125;/** * &#123;@inheritDoc&#125; * * &lt;p&gt;This implementation returns &#123;@code listIterator(0)&#125;. * 這個實現返回listIterator(0) * * @see #listIterator(int) */public ListIterator&lt;E&gt; listIterator() &#123; return listIterator(0);&#125; /** * &#123;@inheritDoc&#125; * * &lt;p&gt;This implementation returns a straightforward implementation of the * 這個實現返回了一個簡單的ListIterator接口的實現. * &#123;@code ListIterator&#125; interface that extends the implementation of the * 這個實現擴展了由iterator()方法返回的Iterator接口的實現. * &#123;@code Iterator&#125; interface returned by the &#123;@code iterator()&#125; method. * The &#123;@code ListIterator&#125; implementation relies on the backing list&apos;s * 這個ListIterator實現依賴於集合的get(int),set(int,E),add(int,E)以及 * &#123;@code get(int)&#125;, &#123;@code set(int, E)&#125;, &#123;@code add(int, E)&#125; * and &#123;@code remove(int)&#125; methods. * remove(int)方法為基礎. * * &lt;p&gt;Note that the list iterator returned by this implementation will * 注意由這個實現返回的list迭代器在響應remove,set,add時會拋出一個異常. * throw an &#123;@link UnsupportedOperationException&#125; in response to its * &#123;@code remove&#125;, &#123;@code set&#125; and &#123;@code add&#125; methods unless the * 除非這個list的remove,set,add方法重寫了. * list&apos;s &#123;@code remove(int)&#125;, &#123;@code set(int, E)&#125;, and * &#123;@code add(int, E)&#125; methods are overridden. * * &lt;p&gt;This implementation can be made to throw runtime exceptions in the * 這個實現在並發改變時會拋出一個運行時異常, * face of concurrent modification, as described in the specification for * the (protected) &#123;@link #modCount&#125; field. * 在受保護的modCount域中詳細的描述 * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public ListIterator&lt;E&gt; listIterator(final int index) &#123; rangeCheckForAdd(index); // 範圍校驗 return new ListItr(index); // private 內部類&#125;private void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; size()) // 索引超出size範圍，數組越界異常 throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;private class Itr implements Iterator&lt;E&gt; &#123; /** * Index of element to be returned by subsequent call to next. * 由子序列調用下一個返回的元素的索引 */ int cursor = 0; /** * Index of element returned by most recent call to next or * 由最近調用的後繼或前驅返回的元素的索引 * previous. Reset to -1 if this element is deleted by a call * 如果調用remove使得元素刪除了，則重置為-1 * to remove. */ int lastRet = -1; /** * The modCount value that the iterator believes that the backing * 迭代器相信list支持的modCount值應該存在. * List should have. If this expectation is violated, the iterator * 如果違反了期望, * has detected concurrent modification. * 這個迭代器會檢測到並發的改變. */ int expectedModCount = modCount; // 判斷是否存在下一個 public boolean hasNext() &#123; return cursor != size(); &#125; // 返回下一個元素 public E next() &#123; // fail-fast檢測 checkForComodification(); try &#123; int i = cursor; E next = get(i); lastRet = i; cursor = i + 1; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; // 移除 public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125;private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; cursor = index; &#125; // 存在前向元素 public boolean hasPrevious() &#123; return cursor != 0; &#125; // 返回前驅元素 public E previous() &#123; // 檢查元素是否並發修改了，fail-fast機制 checkForComodification(); try &#123; int i = cursor - 1; E previous = get(i); lastRet = cursor = i; return previous; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; // 後繼索引 public int nextIndex() &#123; return cursor; &#125; // 前驅索引 public int previousIndex() &#123; return cursor-1; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.set(lastRet, e); expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; AbstractList.this.add(i, e); lastRet = -1; cursor = i + 1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125;&#125;/** * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;. * 這個list已經結構修改的次數. * Structural modifications are those that change the size of the * 結構修改是 那些list的大小改變了, * list, or otherwise perturb it in such a fashion that iterations in * 或者除此以外的例如迭代器在使用過程中產生不正確結果的狀況. * progress may yield incorrect results. * * &lt;p&gt;This field is used by the iterator and list iterator implementation * 這個域用於有迭代器iterator或者listIterator方法返回的實現. * returned by the &#123;@code iterator&#125; and &#123;@code listIterator&#125; methods. * If the value of this field changes unexpectedly, the iterator (or list * 如果這個域的值無法預料的改變了, * iterator) will throw a &#123;@code ConcurrentModificationException&#125; in * 那麼迭代器會在響應next,remove,previous,set,add操作時拋出一個異常 * response to the &#123;@code next&#125;, &#123;@code remove&#125;, &#123;@code previous&#125;, * &#123;@code set&#125; or &#123;@code add&#125; operations. This provides * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in * 其提供了fail-fast行為,而不是非確定性行為在迭代過程中並發的改變其表面現象. * the face of concurrent modification during iteration. * * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass * 子類中這個域的使用是可選的. * wishes to provide fail-fast iterators (and list iterators), then it * 如果一個子類希望提供fail-fast迭代, * merely has to increment this field in its &#123;@code add(int, E)&#125; and * 那麼他僅僅提供這個與在add,remove(和一些其他的複寫list結構改變的結果的方法)方法 * &#123;@code remove(int)&#125; methods (and any other methods that it overrides * 的增量 * that result in structural modifications to the list). A single call to * &#123;@code add(int, E)&#125; or &#123;@code remove(int)&#125; must add no more than * 單獨的調用add或者remove必須添加不多於這個域的一個， * one to this field, or the iterators (and list iterators) will throw * 或者迭代器拋出一個虛假的異常 * bogus &#123;@code ConcurrentModificationExceptions&#125;. If an implementation * does not wish to provide fail-fast iterators, this field may be * 如果一個實現不希望提供fail-fast迭代，這個域會ignore * ignored. */protected transient int modCount = 0; // fail-fast機制的實現：transient/** * &#123;@inheritDoc&#125; * * &lt;p&gt;This implementation first gets a list iterator that points to the end * 這個實現首先返回一個指向list結果的迭代器 * of the list (with &#123;@code listIterator(size())&#125;). Then, it iterates * (由listIterator(size)提供) * backwards over the list until the specified element is found, or the * 而後,迭代器向後迭代,知道發現指定的元素 * beginning of the list is reached. * 或者到達list的開始. * * @throws ClassCastException &#123;@inheritDoc&#125; * @throws NullPointerException &#123;@inheritDoc&#125; */public int lastIndexOf(Object o) &#123; ListIterator&lt;E&gt; it = listIterator(size()); if (o==null) &#123; while (it.hasPrevious()) // 向後遍歷 if (it.previous()==null) // 後繼是否為null return it.nextIndex(); &#125; else &#123; while (it.hasPrevious()) if (o.equals(it.previous())) return it.nextIndex(); &#125; return -1;&#125;/** * Removes all of the elements from this list (optional operation). * 從集合中移除所有的元素 * The list will be empty after this call returns. * 這個方法調用後會返回一個empty集合 * * &lt;p&gt;This implementation calls &#123;@code removeRange(0, size())&#125;. * * &lt;p&gt;Note that this implementation throws an * &#123;@code UnsupportedOperationException&#125; unless &#123;@code remove(int * index)&#125; or &#123;@code removeRange(int fromIndex, int toIndex)&#125; is * overridden. * * @throws UnsupportedOperationException if the &#123;@code clear&#125; operation * is not supported by this list */public void clear() &#123; removeRange(0, size());&#125;/** * Removes from this list all of the elements whose index is between * 從集合中移除包含fromIndex索引到toIndex除外之間的所有元素。[fromIndex,toIndex) * &#123;@code fromIndex&#125;, inclusive, and &#123;@code toIndex&#125;, exclusive. * Shifts any succeeding elements to the left (reduces their index). * 改變任何成功的元素會向左減少他們的索引. * This call shortens the list by &#123;@code (toIndex - fromIndex)&#125; elements. * 這個方法調用有(toIndex-fromIndex)元素縮短集合. * (If &#123;@code toIndex==fromIndex&#125;, this operation has no effect.) * 如果 toIndex == fromIndex ，那麼，這個操作不熟任何影響 * * &lt;p&gt;This method is called by the &#123;@code clear&#125; operation on this list * 這個方法由list或他的子list的clear方法調用 * and its subLists. Overriding this method to take advantage of * the internals of the list implementation can &lt;i&gt;substantially&lt;/i&gt; * 複寫這個方法能夠使得list實現的內部有利條件 * improve the performance of the &#123;@code clear&#125; operation on this list * 提高list和他的子list的clear操作性能 * and its subLists. * * &lt;p&gt;This implementation gets a list iterator positioned before * 這個實現在fromIndex之前獲得一個迭代器位置, * &#123;@code fromIndex&#125;, and repeatedly calls &#123;@code ListIterator.next&#125; * 並且重複調用ListIterator.next方法在ListIterator.remove方法之後， * followed by &#123;@code ListIterator.remove&#125; until the entire range has * 直到移除了整個範圍 * been removed. &lt;b&gt;Note: if &#123;@code ListIterator.remove&#125; requires linear * 注意：如果ListIterator.remove需要線性時間 * time, this implementation requires quadratic time.&lt;/b&gt; * 整個實現需要平方的時間 * * @param fromIndex index of first element to be removed * @param toIndex index after last element to be removed */protected void removeRange(int fromIndex, int toIndex) &#123; ListIterator&lt;E&gt; it = listIterator(fromIndex); for (int i=0, n=toIndex-fromIndex; i&lt;n; i++) &#123; it.next(); it.remove(); &#125;&#125;/** * Returns an iterator over the elements in this list in proper sequence. * 返回在這個list中的正確的序列的迭代器 * * &lt;p&gt;This implementation returns a straightforward implementation of the * 這個實現返回一個有迭代接口返回的簡單實現 * iterator interface, relying on the backing list&apos;s &#123;@code size()&#125;, * 依託list的size(),get(int)以及remove(int)方法 * &#123;@code get(int)&#125;, and &#123;@code remove(int)&#125; methods. * * &lt;p&gt;Note that the iterator returned by this method will throw an * &#123;@link UnsupportedOperationException&#125; in response to its * &#123;@code remove&#125; method unless the list&apos;s &#123;@code remove(int)&#125; method is * overridden. * * &lt;p&gt;This implementation can be made to throw runtime exceptions in the * face of concurrent modification, as described in the specification * for the (protected) &#123;@link #modCount&#125; field. * * @return an iterator over the elements in this list in proper sequence */public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125;/** * Compares the specified object with this list for equality. Returns * 比較指定的obj與此list的相等性. * &#123;@code true&#125; if and only if the specified object is also a list, both * 當且僅當指定的obj也是一個list， * lists have the same size, and all corresponding pairs of elements in * 兩個list有相同size * the two lists are &lt;i&gt;equal&lt;/i&gt;. (Two elements &#123;@code e1&#125; and * 並且所有相應元素對在兩個list中都是相等的 * &#123;@code e2&#125; are &lt;i&gt;equal&lt;/i&gt; if &#123;@code (e1==null ? e2==null : * e1.equals(e2))&#125;.) In other words, two lists are defined to be * equal if they contain the same elements in the same order.&lt;p&gt; * 換句話，兩個list如果他們在相同的排列中包含相同的元素則標記為相等 * * This implementation first checks if the specified object is this * 這個實現首先檢查指定的元素是不是當前list * list. If so, it returns &#123;@code true&#125;; if not, it checks if the * 如果是，返回true;如果不是，檢查指定的obj是否是一個list * specified object is a list. If not, it returns &#123;@code false&#125;; if so, * 如果不是，返回false; * it iterates over both lists, comparing corresponding pairs of elements. * 如果是，迭代兩個list,比較相應的元素. * If any comparison returns &#123;@code false&#125;, this method returns * 如果任意比較返回了false, * &#123;@code false&#125;. If either iterator runs out of elements before the * 那麼這個方法返回false;如果任意迭代器在另一些前運行出元素範圍，則返回false * other it returns &#123;@code false&#125; (as the lists are of unequal length); * (由於list存在不等的長度) * otherwise it returns &#123;@code true&#125; when the iterations complete. * 當迭代器完成，返回true * * @param o the object to be compared for equality with this list * @return &#123;@code true&#125; if the specified object is equal to this list */public boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof List)) return false; ListIterator&lt;E&gt; e1 = listIterator(); ListIterator e2 = ((List) o).listIterator(); while (e1.hasNext() &amp;&amp; e2.hasNext()) &#123; E o1 = e1.next(); Object o2 = e2.next(); if (!(o1==null ? o2==null : o1.equals(o2))) return false; &#125; return !(e1.hasNext() || e2.hasNext());&#125;]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- AbstractCollection -- (六)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F07%2FCollections-AbstractCollection.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 AbstractCollection 頂層抽象類詳解 (三)這一節主要學習集合框架中的AbstractCollection頂層抽象類的成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ AbstractCollection Collection接口頂層抽象類 定義了最小化的一般通用的方法實現 AbstractCollection抽象類包含方法: 實現類源碼解析:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323/** * &#123;@inheritDoc&#125; * &lt;p&gt;This implementation iterates over the elements in the collection, * 這個實現迭代集合中的所有元素 * checking each element in turn for equality with the specified element. * 依次檢查每一個元素與指定元素相等性 * * @throws ClassCastException &#123;@inheritDoc&#125; * @throws NullPointerException &#123;@inheritDoc&#125; */public boolean contains( Object o )&#123; /* 在此抽象類中,iterator()方法為抽象方法,因此此方法要更具具體實現類中的迭代實現算法返回迭代器 */ Iterator&lt;E&gt; it = iterator(); if ( o == null ) //判斷指定元素是否為null &#123; /* 為空,依次判斷本集合中的元素是否為null,存在，則返回true */ /* 說明此方法，可以包含null元素,且存在null元素時，判定為包含*/ while ( it.hasNext() ) if ( it.next() == null ) return true; &#125; else &#123; /* 如果指定元素不為null,依次判斷集合中的元素與指定元素是否相等 */ while ( it.hasNext() ) if ( o.equals( it.next() ) ) return true; &#125; return false;&#125; /** * &#123;@inheritDoc&#125; * &lt;p&gt;This implementation returns an array containing all the elements * 這個實現返回一個數組，包含了所有的元素. * returned by this collection&apos;s iterator, in the same order, stored in * 由這個集合的迭代器,按照相同的順序, * consecutive elements of the array, starting with index &#123;@code 0&#125;. * 從索引0開始的連貫的數組中的元素. * The length of the returned array is equal to the number of elements * 返回的數組的長度等於由迭代器返回的元素的個數, * returned by the iterator, even if the size of this collection changes * 甚至這個集合的大小在迭代過程中改變了 * during iteration, as might happen if the collection permits * 如果集合允許在迭代中並發的改變是可發生的. * concurrent modification during iteration. The &#123;@code size&#125; method is * called only as an optimization hint; the correct result is returned * size方法僅僅作為一個優化的提示被調用;正確的結果可返回 * even if the iterator returns a different number of elements. * 儘管迭代者返回一個不同元素個數 * &lt;p&gt;This method is equivalent to: * 等價的 * &lt;pre&gt; &#123;@code * List&lt;E&gt; list = new ArrayList&lt;E&gt;(size()); * for (E e : this) * list.add(e); * return list.toArray(); * &#125;&lt;/pre&gt; */public Object[] toArray()&#123; // Estimate size of array; be prepared to see more or fewer elements // 預估數組的大小 Object[] r = new Object[ size() ]; Iterator&lt;E&gt; it = iterator(); for ( int i = 0 ; i &lt; r.length ; i++ ) &#123; if ( !it.hasNext() ) // fewer elements than expected //當集合中不存在下一個元素時，返回一個新的拷貝的數組. return Arrays.copyOf( r, i ); r[ i ] = it.next(); //將集合迭代元素依次放入臨時Obj[]中 &#125; /* 如果size為0，判斷集合是否有下一個元素 */ /* 如果不存在，返回一個空的數組 */ /* 如果存在，進行finishToArray()操作 */ return it.hasNext() ? finishToArray( r, it ) : r;&#125; /** * Copies the specified array, truncating or padding with nulls (if necessary) * 拷貝指定的數組，用null截斷或者填充(如果必須的) * so the copy has the specified length. For all indices that are * 因此這個拷貝有一個指定的長度. * valid in both the original array and the copy, the two arrays will * 對於所有的在元array與拷貝array中有效的指數, * contain identical values. For any indices that are valid in the * 兩個數組將包含相同的值. * copy but not the original, the copy will contain &lt;tt&gt;null&lt;/tt&gt;. * 對於一些在copy中但不在元數組中的指標,拷貝將包含null. * Such indices will exist if and only if the specified length * 一些指標當且僅當在指定的長度時存在比起元數組更長 * is greater than that of the original array. * The resulting array is of exactly the same class as the original array. * 返回的數組恰好與元數組相同的類. * * @param original the array to be copied * 要拷貝的原數組 * @param newLength the length of the copy to be returned * 拷貝數組要返回的長度 * @return a copy of the original array, truncated or padded with nulls * 返回一個原數組的拷貝, * to obtain the specified length * 用null截斷或者填充來獲得一個指定的長度. * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative * 如果長度為負數 * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null * 如果元數組為null * @since 1.6 */public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass());&#125;/** * Copies the specified array, truncating or padding with nulls (if necessary) * so the copy has the specified length. For all indices that are * valid in both the original array and the copy, the two arrays will * contain identical values. For any indices that are valid in the * copy but not the original, the copy will contain &lt;tt&gt;null&lt;/tt&gt;. * Such indices will exist if and only if the specified length * is greater than that of the original array. * The resulting array is of the class &lt;tt&gt;newType&lt;/tt&gt;. * * @param original the array to be copied * @param newLength the length of the copy to be returned * @param newType the class of the copy to be returned * @return a copy of the original array, truncated or padded with nulls * to obtain the specified length * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null * @throws ArrayStoreException if an element copied from * &lt;tt&gt;original&lt;/tt&gt; is not of a runtime type that can be stored in * an array of class &lt;tt&gt;newType&lt;/tt&gt; * @since 1.6 */public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; /* 類型判斷 */ T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance( newType.getComponentType(), newLength); /* native 本地數組拷貝算法 */ System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; /** * Reallocates the array being used within toArray when the iterator * 重新分配數組用於在toArray內，迭代器返回比期望更多的元素時， * returned more elements than expected, and finishes filling it from * 并完成從迭代器填充. * the iterator. * * @param r the array, replete with previously stored elements * 一個數組，充滿了先前的元素的 * @param it the in-progress iterator over this collection * 迭代這個集合的迭代器 * * @return array containing the elements in the given array, plus any * 返回數組包含了在特定數組中的元素, * further elements returned by the iterator, trimmed to size * 由迭代器返回添加任意將來的元素,消減規模 */private static &lt;T&gt; T[] finishToArray( T[] r, Iterator&lt;?&gt; it )&#123; int i = r.length; while ( it.hasNext() ) &#123; int cap = r.length; if ( i == cap ) &#123; int newCap = cap + ( cap &gt;&gt; 1 ) + 1; // overflow-conscious code // 合理的溢出代碼 if ( newCap - MAX_ARRAY_SIZE &gt; 0 ) newCap = hugeCapacity( cap + 1 ); r = Arrays.copyOf( r, newCap ); &#125; r[ i++ ] = ( T ) it.next(); &#125; // trim if overallocated return ( i == r.length ) ? r : Arrays.copyOf( r, i );&#125;/*最小容量校驗，負值判斷,0x7fffffff最大整數判斷*/private static int hugeCapacity( int minCapacity )&#123; if ( minCapacity &lt; 0 ) // overflow throw new OutOfMemoryError( &quot;Required array size too large&quot; ); return ( minCapacity &gt; MAX_ARRAY_SIZE ) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125;/** * &#123;@inheritDoc&#125; * &lt;p&gt;This implementation returns an array containing all the elements * returned by this collection&apos;s iterator in the same order, stored in * consecutive elements of the array, starting with index &#123;@code 0&#125;. * 連貫的數 * If the number of elements returned by the iterator is too large to * 如果由迭代器返回的元素的個數太大了 * fit into the specified array, then the elements are returned in a * 而不適合指定的數組, * newly allocated array with length equal to the number of elements * 那麼在一個重新分配的由迭代者返回元素的個數相等的長度的數組中返回元素 * returned by the iterator, even if the size of this collection * changes during iteration, as might happen if the collection permits * 儘管集合在迭代中改變了大小, * concurrent modification during iteration. The &#123;@code size&#125; method is * 如果集合允許在迭代中並發修改的發生. * called only as an optimization hint; the correct result is returned * 優化的提示 * even if the iterator returns a different number of elements. * &lt;p&gt;This method is equivalent to: * &lt;pre&gt; &#123;@code * List&lt;E&gt; list = new ArrayList&lt;E&gt;(size()); * for (E e : this) * list.add(e); * return list.toArray(a); * &#125;&lt;/pre&gt; * * @throws ArrayStoreException &#123;@inheritDoc&#125; * @throws NullPointerException &#123;@inheritDoc&#125; */public &lt;T&gt; T[] toArray( T[] a )&#123; // Estimate size of array; be prepared to see more or fewer elements int size = size(); //創建一個新的數組，由指定類型，底層由native方法newArray實現數組的創建 T[] r = a.length &gt;= size ? a : ( T[] ) java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size ); Iterator&lt;E&gt; it = iterator(); for ( int i = 0 ; i &lt; r.length ; i++ ) &#123; if ( !it.hasNext() ) &#123; // fewer elements than expected if ( a == r ) &#123; r[ i ] = null; // null-terminate &#125; else if ( a.length &lt; i ) &#123; return Arrays.copyOf( r, i ); &#125; else &#123; System.arraycopy( r, 0, a, 0, i ); if ( a.length &gt; i ) &#123; a[ i ] = null; &#125; &#125; return a; &#125; r[ i ] = ( T ) it.next(); &#125; // more elements than expected return it.hasNext() ? finishToArray( r, it ) : r;&#125; /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * 一些vm在數組里提供某些header信息 * Attempts to allocate larger arrays may result in * 嘗試分配更大的數組會拋出OutOfMemoryError. * OutOfMemoryError: Requested array size exceeds VM limit * 請求的數組大小超過vm的限制 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; //因此，某些vm的數組頭信息大小為 8 ？/** * &#123;@inheritDoc&#125; * &lt;p&gt;This implementation always throws an * 這個實現總是拋出一個UnsupportedOperationException * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt;. * * @throws UnsupportedOperationException &#123;@inheritDoc&#125; * @throws ClassCastException &#123;@inheritDoc&#125; * @throws NullPointerException &#123;@inheritDoc&#125; * @throws IllegalArgumentException &#123;@inheritDoc&#125; * @throws IllegalStateException &#123;@inheritDoc&#125; */public boolean add( E e )&#123; throw new UnsupportedOperationException(); // 留下個疑問，為何總是拋出異常，是不是在具體的實現類里重寫了此方法 ？ &#125; /** * Returns a string representation of this collection. The string * 返回這個集合的字符串表示. * representation consists of a list of the collection&apos;s elements in the * 這個字符串表示包含集合元素的列表 * order they are returned by its iterator, enclosed in square brackets * 由他的迭代器返回的順序的列表,在封閉的括號內 * (&lt;tt&gt;&quot;[]&quot;&lt;/tt&gt;). Adjacent elements are separated by the characters * 合適的元素由逗號和空格分離 * &lt;tt&gt;&quot;, &quot;&lt;/tt&gt; (comma and space). Elements are converted to strings as * 由String.valueOf()方法轉換為字符串. * by &#123;@link String#valueOf(Object)&#125;. * * @return a string representation of this collection */public String toString()&#123; Iterator&lt;E&gt; it = iterator(); if ( !it.hasNext() ) return &quot;[]&quot;; StringBuilder sb = new StringBuilder(); sb.append( &apos;[&apos; ); for ( ; ; ) &#123; E e = it.next(); sb.append( e == this ? &quot;(this Collection)&quot; : e ); if ( !it.hasNext() ) return sb.append( &apos;]&apos; ).toString(); sb.append( &apos;,&apos; ).append( &apos; &apos; ); &#125;&#125; /* Note that this implementation will throw an UnsupportedOperationException if the iterator returned by the iterator method does not implement the remove method and this collection contains one or more elements in common with the specified collection *//* 如果是實現類沒有實現remove方法,以下方法在調用時將會拋出異常 UnsupportedOperationException */public boolean remove( Object o )&#123; .. &#125;public boolean addAll( java.util.Collection&lt;? extends E&gt; c )&#123; .. &#125;public boolean retainAll( java.util.Collection&lt;?&gt; c )&#123; .. &#125;public boolean removeAll( java.util.Collection&lt;?&gt; c )&#123; .. &#125;public void clear()&#123; .. &#125;]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- List -- (五)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F03%2FCollections-List-1.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 List 接口詳解 (二)這一節主要學習集合框架中的Collection接口、相關子接口、實現類以及成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ List接口分析 List接口包含方法: 12345678910111213boolean contains(Object o); // (o == null ? e == null : o.equals(e)) ***(NullPointerException)if the specified element is null and this list does not permit null elementsObject[] toArray(); //(in proper sequence). In other words, this method must allocate a new array even if this list is backed by an arrayboolean addAll(int index, java.util.Collection&lt;? extends E&gt; c); // IndexOutOfBoundsException (index &lt; 0 || index &gt; size())boolean retainAll( java.util.Collection&lt;?&gt; c); // removes from this list all of its elements that are not contained in the specified collectionboolean equals(Object o); // (e1 == null ? e2 == null : eq.equals(e2))int hashCode(); // This ensures that list1.equals(list2) implies that list1.hashCode()==list2.hashCode() for any two listsE get(int index); // IndexOutOfBoundsException (index &lt; 0 || index &gt;= size())E set(int index, E element); // Replaces the element 替換指定位置的元素用指定的元素void add(int index, E element); //Inserts the specified element 在指定的位置添加指定的元素.改變元素當前的位置.任何後續的元素在其右邊E remove(int index); //Returns the element that was removed from the list.int indexOf(Object o); //the index of the first occurrence ,More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such indexListIterator&lt;E&gt; listIterator(int index); // The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one.List&lt;E&gt; subList(int fromIndex, int toIndex); // low endpoint (inclusive) of the subList,high endpoint (exclusive) of the subList(IndexOutOfBoundsException) (fromIndex &lt; 0 || toIndex &gt; size || fromIndex &gt; toIndex)]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections -- Collection -- (四)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F01%2FCollections-Collection-1.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 之 Collection 接口詳解 (一)這一節主要學習集合框架中的Collection接口、相關子接口、實現類以及成員屬性、方法等具體實現相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/ Collection接口分析： Collection接口繼承了Iterable接口，Iterable接口存在一個Iterator對象. 123Iterator接口與Enumeration類似,都用於遍歷.Iterator接口增加了remove方法,可以修改集合內部元素.Iterator接口中的方法命名具有更好的語義定義. Collection接口包含方法: 12345678910111213141516int size(); //集合元素大小,最大返回Integer.MAX_VALUEboolean isEmpty(); //如果集合沒有包含任何元素，則返回trueboolean contains( Object o ); //當且僅當集合包含至少一個元素符合(o == null ? e == null : o.equals(s))規則時返回trueIterator&lt;E&gt; iterator(); //返回一個集合的迭代器,通常不保證元素迭代順序，除非實現類提供了排序保證Object[] toArray(); //返回包含集合所有元素的數組,如果集合的迭代有保證順序，那麼這個方法也要保證元素的順序&lt;T&gt; T[] toArray( T[] a ); //返回指定類型的包含集合元素的數組,如果指定數組為null則會拋出異常boolean add( E e ); //添加指定元素，集合添加元素改變返回ｔｒｕｅ，如果已存在或者重複情況下，返回ｆａｌｓｅ，或者拋出相應異常.boolean remove( Object o ); //移除指定元素從集合中,如果集合因此方法調用結果改變了則返回trueboolean containsAll( Collection&lt;?&gt; c ); //判定當前集合是否包含指定集合的所有元素,包含了則返回trueboolean addAll( Collection&lt;? extends E&gt; c ); //添加指定集合的所有元素到這個集合中boolean removeAll( Collection&lt;?&gt; c ); //將集合中的所有與指定集合匹配的元素移出boolean retainAll( Collection&lt;?&gt; c ); //將當前集合中所有不含在指定集合中的元素移出void clear(); //清空集合，empty// Comparison and hashingboolean equals( Object o ); //判斷指定對象與這個集合是否相等int hashCode(); // 返回一個集合的hashcode值,c1.equals(c2),意味著c1.hashCode() == c2.hashCode().]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections Framework Interface UML -- (三)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F12%2F01%2FCollections-Framework-Interface-UML.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 Collections 框架 UMLCollections集合框架包含兩大部分,一部分以Collection接口為基礎,另一部分以Map接口為基礎.相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Outline of the Collection Framework -- (二)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F11%2F30%2FOutline-of-the-Collections-Framework.html</url>
    <content type="text"><![CDATA[簡介：Collections Framework. JDK1.7 集合框架系統學習 (二) 概述集合框架API DOC簡介英文翻譯練習。相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/※ 注：此翻譯僅僅為個人學習JDK文檔及補習英文所做，如果您希望看到更加準確的翻譯，請自行搜尋中文文檔 因英文水平不足為您帶來的不便請諒解. API Specification API詳述 API Reference - An annotated outline of the classes and interfaces comprising the collections framework, with links into the JavaDoc.API參考 - 一個有注釋的類和接口的概述組成集合框架,連接至JavaDoc.The collections framework consists of: 集合框架包含: Collection interfaces - The primary means by which collections are manipulated. 集合接口 - 通過集合操作的主要手段. Collection - A group of objects.Clollection - 一組對象.No assumptions are made about the order of the collection (if any) or whether it can contain duplicate elements.沒有假設關於排序的集合是可用的,如果有的話,或者集合包含重複的元素. Set - The familiar set abstraction.Set - 常見的抽象set.No duplicate elements permitted.不允許重複的元素.May or may not be ordered.可排序的.Extends the Collection interface.擴展Collection接口. List - Ordered collection, also known as a sequence.List - 排序的集合,同時作為一個已知的序列.Duplicates are generally permitted.通常允許重複.Allows positional access.允許定位存取.Extends the Collection interface.擴展自Collection接口. Queue - A collection designed for holding elements before processing.Queue - 集合可以在處理前保存元素.Besides basic Collection operations,包含基本的集合操作以外的操作,queues provide additional insertion, extraction, and inspection operations.隊列提供可添加的插入,提取和檢視操作. Deque - A double ended queue, supporting element insertion and removal at both ends.Deque - 一個雙向的queue,支持元素在兩端插入和移除.Extends the Queue interface.擴展自Queue接口. Map - A mapping from keys to values. Each key can map to one value.Map - 一個k-v影射Map.每個Key影射一個Value. SortedSet - A set whose elements are automatically sorted,SortedSet - 元素自動排序的集合set,either in their natural ordering (see the Comparable interface) or by a Comparator object provided when a SortedSet instance is created.要麼使用自然排序(請看Comparable接口)要麼在SortedSet實例在創建時,由Comparator對象提供排序.Extends the Set interface.擴展自Set接口. SortedMap - A map whose mappings are automatically sorted by key,SortedMap - 一個自動根據Key進行排序的Map,either using the natural ordering of the keys or by a comparator provided when a SortedMap instance is created.要麼使用key的自然排序,要麼在一個SortedMap實例創建時由Comparator提供排序.Extends the Map interface.擴展自Map接口. NavigableSet - A SortedSet extended with navigation methods reporting closest matches for given search targets.NavigableSet - 一個SortedSet的擴展,給搜索目標報告由導航方法搜索到的最近的方法.A NavigableSet may be accessed and traversed in either ascending or descending order.一個NavigableSet可以存取和訪問遞增或遞減的集合. NavigableMap - A SortedMap extended with navigation methods returning the closest matches for given search targets.NavigableMap - 一個SortedMap的擴展,給所搜索的目標返回導航方法搜索到的最近的方法.A NavigableMap can be accessed and traversed in either ascending or descending key order.一個NavigableMap能夠存取和訪問按照Key排序遞增或遞減的集合. BlockingQueue - A Queue with operationsBlockingQueue - queue操作,that wait for the queue to become nonempty when retrieving an element在隊列恢復一個元素成為非空時進行操作,and that wait for space to become available in the queue when storing an element.在隊列中存儲一個元素,成為可用隊列是進行操作.(This interface is part of the java.util.concurrent package.)(這個接口是java.util.concurrent包下的一部分.) TransferQueue - A BlockingQueue in which producers can wait for consumers to receive elements.TransferQueue - 一個BlockingQueue,能夠讓生產者等待消費者接收elements.(This interface is part of the java.util.concurrent package.)(這個接口是java.util.concurrent包的一部分.) BlockingDeque - A Deque with operationsBlockingDeque - Deque操作that wait for the deque to become nonempty when retrieving an element在隊列恢復一個元素成為非空隊列時操作and wait for space to become available in the deque when storing an element.在隊列存儲一個元素成為可操作隊列時操作.Extends both the Deque and BlockingQueue interfaces.擴展自Deque與BlockingQueue兩個接口.(This interface is part of the java.util.concurrent package.)(這個接口是java.util.concurrent包的一部分.) ConcurrentMap - A Map with atomic putIfAbsent, remove, and replace methods.ConcurrentMap - 原子操作,刪除,替換方法的Map.(This interface is part of the java.util.concurrent package.)(這個接口是java.util.concurrent包的一部分.) ConcurrentNavigableMap - A ConcurrentMap that is also a NavigableMap.ConcurrentNavigableMap - 同樣是一個NavigableMap的ConcurrentMap. General-purpose implementations - The primary implementations of the collection interfaces. 通用的實現 - 集合接口主要的實現 HashSet - Hash table implementation of the Set interface.HashSet - 實現了set接口的Hash table.The best all-around implementation of the Set interface.set接口最完整的實現. TreeSet - Red-black tree implementation of the NavigableSet interface.TredSet - NavigableSet接口的Red-black樹實現 LinkedHashSet - Hash table and linked list implementation of the Set interface.LinkedHashSet - Set接口的哈希表與鏈錶的實現An insertion-ordered Set implementation that runs nearly as fast as HashSet.如同HashSet一樣快速的插入排序的set集合 ArrayList - Resizable array implementation of the List interface (an unsynchronized Vector).ArrayList - List接口的可變大小的數組實現(一個非同步的Vector).The best all-around implementation of the List interface.List接口最完整的實現. ArrayDeque - Efficient, resizable array implementation of the Deque interface.ArrayDeque - Deque接口的高效的,可變大小的數組實現. LinkedList - Doubly-linked list implementation of the List interface.LinkedList - List接口的雙向鏈錶實現的接口Provides better performance than the ArrayList implementation if elements are frequently inserted or deleted within the list.提供比ArrayList實現更高性能的實現,如果在list內部元素是序列的插入或者刪除.Also implements the Deque interface. When accessed through the Queue interface, LinkedList acts as a FIFO queue.同樣實現于Deque接口.當存儲訪問Queue接口時,LinkedList當做是一個FIFO的queue. PriorityQueue - Heap implementation of an unbounded priority queue.PriorityQueue - 一個不受限制的優先級queue的堆實現. HashMap - Hash table implementation of the Map interface (an unsynchronized Hashtable that supports null keys and values).HashMap - Map接口的哈希表實現(允許null的key和value的非同步的HashTable).The best all-around implementation of the Map interface.Map接口的最完整的實現. TreeMap Red-black tree implementation of the NavigableMap interface.TreeMap NavigableMap接口的Red-black樹的實現. LinkedHashMap - Hash table and linked list implementation of the Map interface.LinkedHashMap - Map接口的哈希表與鏈錶的實現.An insertion-ordered Map implementation that runs nearly as fast as HashMap.如同HashMap一樣快速的的插入排序的Map.Also useful for building caches (see removeEldestEntry(Map.Entry) ).也可用於構建caches(看 moveEldestEntry(Map.Entry)). Wrapper implementations - Functionality-enhancing implementations for use with other implementations. 封裝的實現 - 一些其他的實現用於功能增強的實現. Accessed solely through static factory methods. 僅僅通過靜態工廠方法進行存儲訪問. Collections.unmodifiableInterface - Returns an unmodifiable view of a specified collectionCollections.unmodifiableInterface - 返回一個特定集合的不可修改的視圖.that throws an UnsupportedOperationException if the user attempts to modify it.如果用戶視圖修改這個視圖，將會拋出一個UnsupportedOperationException異常. Collections.synchronizedInterface - Returns a synchronized collectioncollections.synchronizedInterface - 返回一個同步化的集合that is backed by the specified (typically unsynchronized) collection.這個集合由特定的接口支持(典型的代表非同步化的).As long as all accesses to the backing collection are through the returned collection,所有通過這個返回的集合存儲訪問的支持的接口,thread safety is guaranteed.線程安全是課保證的. Collections.checkedInterface - Returns a dynamically type-safe view of the specified collection,Collections.checkedInterface - 返回特定集合的動態的類型安全的視圖,which throws a ClassCastException if a client attempts to add an element of the wrong type.如果客戶端視圖添加一個錯誤類型的元素，將會破出一個ClassCastException異常.The generics mechanism in the language provides compile-time (static) type checking,這種在語言中的泛型機制提供編譯時(靜態)類型檢查,but it is possible to bypass this mechanism.但是其是可以繞過這種機制的.Dynamically type-safe views eliminate this possibility.動態類型安全視圖排除這種可能. Adapter implementations - Implementations that adapt one collections interface to another: 適配器實現 - 適配一個集合接口或者其他的實現: newSetFromMap(Map) - Creates a general-purpose Set implementation from a general-purpose Map implementation.newSetFromMap(Map) - 通過一個通用的Map集合創建一個通用的Set集合實現. asLifoQueue(Deque) - Returns a view of a Deque as a Last In First Out (LIFO) Queue.asLifoQueue(Deque) - 返回一個作為後勁先出(LIFO)的Queue的Deque的視圖. Convenience implementations - High-performance “mini-implementations” of the collection interfaces. 方便的實現 - 集合接口中的高性能,小實現 Arrays.asList - Enables an array to be viewed as a list.Array.asList - 將一個array看做一個list emptySet, emptyList and emptyMap - Return an immutable empty set, list, or map.emptySet, emptyList and emptyMap - 返回一個不變的空的set,list或者map. singleton, singletonList, and singletonMap - Return an immutable singleton set, list, or map,singleton, singletonList, and singletonMap - 返回一個不變的單實例的set,list或者map,containing only the specified object (or key-value mapping).僅僅包含特定的object(或是key-value影射). nCopies - Returns an immutable list consisting of n copies of a specified object.nCopies - 返回一個由特定object的N個備份組成的不變的list Legacy implementations - Older collection classes were retrofitted to implement the collection interfaces. 遺留實現 - 實現集合的接口翻新舊的集合類. Vector - Synchronized resizable array implementation of the List interface with additional legacy methods.Vector - 用於添加遺留方法的List接口中的同步化的可變大小的數組實現. Hashtable - Synchronized hash table implementation of the Map interface that does not allow null keys or values,Hashtable - 同步化的Map接口哈希表實現,這個類型不允許空的key和value,plus additional legacy methods.加上額外的遺留方法. Special-purpose implementations 特殊的實現 WeakHashMap - An implementation of the Map interface that stores only weak references to its keys.WeakHashMap - 僅僅存儲了弱引用作為key的map接口的一個實現.Storing only weak references enables key-value pairs to be garbage collected when the key is no longer referenced outside of the WeakHashMap.僅僅存儲弱引用是的key-value鍵值對能夠垃圾回收,當Key值在WeakHashMap外沒有更長的引用時.This class is the easiest way to use the power of weak references.這個列是弱引用使用精力中最簡單的方法.It is useful for implementing registry-like data structures,對於實現註冊表狀的數據結構是有用的.where the utility of an entry vanishes when its key is no longer reachable by any thread.一個實體的功能消失是他的Keys在任何線程中不會獲取到. IdentityHashMap - Identity-based Map implementation based on a hash table.IdentityHashMap - 基於一個哈希表的以Map身份出現的實現.This class is useful for topology-preserving object graph transformations (such as serialization or deep copying).這個類有助於保留圖形變換的拓撲行的實體(例如序列化或者深拷貝).To perform these transformations, you must maintain an identity-based “node table” that keeps track of which objects have already been seen.要執行這些轉換,你必須維護一個基於身份標示的”node table”,持續追蹤這些以觀察到的實體.Identity-based maps are also used to maintain object-to-meta-information mappings in dynamic debuggers and similar systems.基於map的身份標示同樣擁有保持元實體meta信息在動態的調試和簡單的系統中影射.Finally, identity-based maps are useful in preventing “spoof attacks” resulting from intentionally perverse equals methods.最後,基於maps的身份標示有效防止故意造成的”欺騙攻擊”方法.(IdentityHashMap never invokes the equals method on its keys.) An added benefit of this implementation is that it is fast.(IdentityHashMap 永遠不能在他的keys中調用equals方法.) CopyOnWriteArrayList - A List implementation backed by an copy-on-write array.CopyOnWriteArrayList - 一個基於copy-on-write數組實現的List實現.All mutative operations (such as add, set, and remove) are implemented by making a new copy of the array.所有的變化的操作(例如add,set和remove)都是在一個新的拷貝的數組中作用的.No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw ConcurrentModificationException.在迭代中同步化是非必須的,迭代因子收到保護永遠都不回拋出ConcurrentModificationExceptoin.This implementation is well-suited to maintaining event-handler lists這個實先非常適合維護事件處理列表.(where change is infrequent, and traversal is frequent and potentially time-consuming).(改變是稀有的,遍歷是頻繁的而且可能耗時的). CopyOnWriteArraySet - A Set implementation backed by a copy-on-write array.CopyOnWriteArraySet - 一個基於copy-on-write數組實現的set實現.This implementation is similar to CopyOnWriteArrayList.這個實現類似於CopyOnWriteArrayList.Unlike most Set implementations, the add, remove, and contains methods require time proportional to the size of the set.和大多數set實現不同的是, add, remove, contains方法需要set大小的時間均衡.This implementation is well suited to maintaining event-handler lists that must prevent duplicates.這個實先非常適合維護事件處理那些必須防止副本的列表. EnumSet - A high-performance Set implementation backed by a bit vector.EnumSet - 基於一個bit的vector實現的高性能的set實現.All elements of each EnumSet instance must be elements of a single enum type.每一個EnumSet的實體的所有元素必須是一個單實例的enum類型的元素. EnumMap - A high-performance Map implementation backed by an array.EnumMap - 基於一個數組實現的的高性能的Map實現.All keys in each EnumMap instance must be elements of a single enum type.每一個EnumMap的實體中的所有keys都必須是一個單實例的enum類型的元素. Concurrent implementations - These implementations are part of java.util.concurrent. 並發的實現 - 這些實現是java.util.concurrent包的一部分. ConcurrentLinkedQueue - An unbounded first in, first out (FIFO) queue based on linked nodes.ConcurrentLinkedQueue - 一個基於linked節點的不受限制的先進先出隊列. LinkedBlockingQueue - An optionally bounded FIFO blocking queue backed by linked nodes.LinkedBlockingQueue - 一個基於linked節點的隨意限制的先進先出阻塞隊列. ArrayBlockingQueue - A bounded FIFO blocking queue backed by an array.ArrayBlockingQueue - 一個基於數組的受限制的先進先出的阻塞隊列. PriorityBlockingQueue - An unbounded blocking priority queue backed by a priority heap.PriorityBlockingQueue - 一個基於優先級堆的不受限制的阻塞隊列. DelayQueue - A time-based scheduling queue backed by a priority heap.DelayQueue - 一個基於優先級堆的基於時間安排的隊列. SynchronousQueue - A simple rendezvous mechanism that uses the BlockingQueue interface.SynchronousQueue - 一個用於BlockingQueue接口的簡單機制 LinkedBlockingDeque - An optionally bounded FIFO blocking deque backed by linked nodes.LinkedBlockingDeque - 一個由linked節點支持的隨意有界的先進先出的阻塞deque. LinkedTransferQueue - An unbounded TransferQueue backed by linked nodes.LinkedTransferQueue - 一個由linked節點支持的不受限制的TransferQueue. ConcurrentHashMap - A highly concurrent, high-performance ConcurrentMap implementation based on a hash table.ConcurrentHashMap - 一個由哈希表支持的高並發，高性能的ConcurrentMap實現.This implementation never blocks when performing retrievals and enables the client to select the concurrency level for updates.這個是實現在執行檢索時永遠不會阻塞,並且能夠使客戶端在更新時選擇並發級別.It is intended as a drop-in replacement for Hashtable.這個類可以作為HashTable的替代類.In addition to implementing ConcurrentMap,除了添加實現ConcurrentMap,it supports all of the legacy methods of Hashtable.它支持所有的Hashtable中的遺留方法. ConcurrentSkipListSet - Skips list implementation of the NavigableSet interface.ConcurrentSkipListSet - NavigableSet接口中的滑過list接口. ConcurrentSkipListMap - Skips list implementation of the ConcurrentNavigableMap interface.ConcurrentSkipListMap - ConcurrentNavigableMap接口中的滑過list接口 Abstract implementations - Skeletal implementations of the collection interfaces to facilitate custom implementations. 抽象的實現 - 集合接口的實現骨架方便自定義的實現. AbstractCollection - Skeletal Collection implementation that is neither a set nor a list (such as a “bag” or multiset).AbstractCollection - 集合實現的骨架既不是一個set也不是一個list(例如一個”bag”或者多重集合). AbstractSet - Skeletal Set implementation.AbstractSet - Set實現的骨架. AbstractList - Skeletal List implementation backed by a random access data store (such as an array).AbstractList - 支持隨機存儲訪問數據倉庫的List實現的骨架(例如一個array). AbstractSequentialList - Skeletal List implementation backed by a sequential access data store (such as a linked list).AbstractSequentialList - 支持序列存儲訪問數據倉庫的List實現骨架(例如一個linked list). AbstractQueue - Skeletal Queue implementation.AbstractQueue - Queue實現的骨架. AbstractMap - Skeletal Map implementation.AbstractMap - Map實現的骨架. Algorithms - The Collections class contains these useful static methods. 算法 - Collections類包含一些有用的靜態方法. sort(List) - Sorts a list using a merge sort algorithm,sort(List) - 使用合併排序算法排序一個list,which provides average case performance comparable to a high quality quicksort,提供一個平均水平下的堪比高性能快速排序的性能,guaranteed O(nlog n) performance (unlike quicksort),保證O(nlog n)性能(不像快速排序),and stability (unlike quicksort).和穩定性(不像快排).A stable sort is one that does not reorder equal elements.一個穩定的排序是不會重複排列相同元素的. binarySearch(List, Object) - Searches for an element in an ordered list using the binary search algorithm.binarySearch(List, Object) - 使用二分法查找算法在一個已排序的list中查找一個元素. reverse(List) - Reverses the order of the elements in a list.reverse(List) - 在一個list中反轉元素的順序. shuffle(List) - Randomly changes the order of the elements in a list.shuffle(List) - 在一個list中隨意的改變元素的順序. fill(List, Object) - Overwrites every element in a list with the specified value.fill(List, Object) - 使用特定的值重寫在list中的每一個元素. copy(List dest, List src) - Copies the source list into the destination list.copy(List dest, List src) - 拷貝源list到目標list中. min(Collection) - Returns the minimum element in a collection.min(Collection) - 返回一個集合中最小的元素. max(Collection) - Returns the maximum element in a collection.max(collection) - 返回一個集合中最大的元素. rotate(List list, int distance) - Rotates all of the elements in the list by the specified distance.rotate(List list, int distance) - 按照指定的距離來旋轉集合中所有的元素. replaceAll(List list, Object oldVal, Object newVal) - Replaces all occurrences of one specified value with another.replaceAll(List list, Object oldVal, oldVal newVal) - 用另一個值替換所有發現的特定的值. indexOfSubList(List source, List target) - Returns the index of the first sublist of source that is equal to target.indexOfSubList(List source, List target) - 返回等於目標列表的源list中的第一個list子列表索引. lastIndexOfSubList(List source, List target) - Returns the index of the last sublist of source that is equal to target.lastIndexOfSubList(List source, List target) - 返回等於目標列表的源list中的最後一個子列表的索引. swap(List, int, int) - Swaps the elements at the specified positions in the specified list.swap(List, int, int) - 在指定的list中交換指定位置的的元素. frequency(Collection, Object) - Counts the number of times the specified element occurs in the specified collection.frequency(collection, Object) - 計數在指定集合中指定元素出現的次數. disjoint(Collection, Collection) - Determines whether two collections are disjoint, in other words, whether they contain no elements in common.disjoint(Collection) - 判斷兩個結合是否是不相交的,換句話說,他們是否包含元素的不同之處. addAll(Collection&lt;? super T&gt;, T…) - Adds all of the elements in the specified array to the specified collection.addAll(collection&lt;? super T&gt;, T…) - 將指定的數組中的所有元素添加至指定的集合. Infrastructure 基礎結構 Iterators - Similar to the familiar Enumeration interface, but more powerful, and with improved method names.迭代器 - 與熟悉的Enumeration接口類型,但更加有力,改良方法名. Iterator - In addition to the functionality of the Enumeration interface,Iterator - 在Enumeration接口添加功能,enables the user to remove elements from the backing collection with well-defined, useful semantics.是的用戶可以支持在更好的定義,有用的語意上移除元素. ListIterator - Iterator for use with lists. In addition to the functionality of the Iterator interface,ListIterator - 對於list有用的迭代器.在Iterator接口中添加功能,supports bidirectional iteration, element replacement, element insertion, and index retrieval.支持雙向的迭代,元素的替換,元素的添加以及索引的檢索. Ordering排序 Comparable - Imparts a natural ordering to classes that implement it.Comparable - 實現這個接口,可以使得classes按照自然排序.The natural ordering can be used to sort a list or maintain order in a sorted set or map.自然排序可以用於排序一個list或者維護一個已排序的set或者map.Many classes were retrofitted to implement this interface.許多類都已經改造為實現這個接口. Comparator - Represents an order relation,Comparator - 代表一個排序關係,which can be used to sort a list or maintain order in a sorted set or map.可以用於排序一個list或者維護一個已排序的set或者map.Can override a type’s natural ordering or order objects of a type that does not implement the Comparable interface.用於複寫一個類型的自然排序或者排序那些不能實現Comparable接口的類型的對象. Runtime exceptions運行時遺產 UnsupportedOperationException - Thrown by collections if an unsupported optional operation is called.UnsupportedOperationException - 如果使用了一個不支持的可選操作會有集合拋出異常. ConcurrentModificationException - Thrown by iterators and list iteratorsConcurrentModificationException - 迭代器和list的迭代器會拋出異常,if the backing collection is changed unexpectedly while the iteration is in progress.當迭代過程中支持的集合發生了意外的改變.Also thrown by sublist views of lists if the backing list is changed unexpectedly.同樣支持的list發生了意外的改變,list的自列表視圖也會拋出異常. Performance執行 RandomAccess - Marker interface that lets List implementations indicate that they support fast (generally constant time) random access.隨機存儲訪問 - 標記接口,使得列表實現支持快速的隨機存儲訪問(一般恆定的時間).This lets generic algorithms change their behavior to provide good performance when applied to either random or sequential access lists.這使得通用的算法改變了他們的表現,無論應用使用隨機或是序列的存儲訪問list,都提供了很好的性能. Array Utilities 數組工具 Arrays - Contains static methods to sort, search, compare, hash, copy, resize, convert to String, and fill arrays of primitives and objects.Arrays - 包含了靜態的方法:sort,search,compare,hash,copy,resize,轉換成字符串以及填充數組的基本類型與對象.]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
        <tag>TRANSLATING</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collections Framework Overview -- (一)]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F11%2F25%2FCollections-Framework-Overview.html</url>
    <content type="text"><![CDATA[簡介：Collections Framework. JDK1.7 集合框架系統學習 (一) 概覽集合框架API DOC簡介英文翻譯練習。相關源碼分析及詳細api文檔移路→Collection接口https://github.com/myhongkongzhen/pro-study-jdk/※ 注：此翻譯僅僅為個人學習JDK文檔及補習英文所做，如果您希望看到更加準確的翻譯，請自行搜尋中文文檔 因英文水平不足為您帶來的不便請諒解. JDK 1.7 API Collections Framework The collections framework is a unified architecture for representing and manipulating[mə’nɪpjulet] collections 集合框架是一個統一的描述和操作集合的架構, enabling them to be manipulated independently of the details of their representation. 使得他們能夠被獨立操作他們所描述的細節. It reduces programming effort while increasing performance. 他降低編程精力當越來越多的執行性能. It enables interoperability among unrelated APIs, 他使得無關的API相互操作成為可能, reduces effort in designing and learning new APIs, 降低設計和學習新API的精力, and fosters software reuse. 并促進軟體的複用. The framework is based on more than a dozen collection interfaces. 這個框架以多餘十二個集合的接口為基礎. It includes implementations of these interfaces and algorithms to manipulate them. 他包含了一些接口的實現和算法來操作他們. Collections Framework OverviewIntroduction The Java platform includes a collections framework. JAVA平台包含一個集合框架. A collection is an object that represents a group of objects (such as the classic Vector class). 集合是一個描述一組實例（例如類型Vector類）的一個實體. A collections framework is a unified architecture for representing and manipulating collections, 集合框架是一個描述和操作集合的統一架構, enabling collections to be manipulated independently of implementation details. 使得集合被不依賴實現細節的操作成為可能. The primary advantages of a collections framework are that it:集合框架最主要的特點如下: Reduces programming effort by providing data structures and algorithms so you don’t have to write them yourself. 降低程式開發精力 以數據結構和算法為條件以至於你無需自己編寫他們. Increases performance by providing high-performance implementations of data structures and algorithms. 提高性能 以高性能的數據結構和算法實現為條件.Because the various implementations of each interface are interchangeable,因為每一個接口多樣的實現是可交換的,programs can be tuned by switching implementations.程序能夠備調整由可轉換的實現. Provides interoperability between unrelated APIs by establishing[ɪˈstæblɪʃ] a common language to pass collections back and forth. 提供無關API之間的相互操作 建立一個通用的可環繞操作集合的語言 Reduces the effort required to learn APIs by requiring you to learn multiple ad hoc collection APIs. 降低必要學習API的精力 必須使得你不得不學習多種特定的集合API Reduces the effort required to design and implement APIs by not requiring you to produce ad hoc collections APIs. 降低必須設計和實現API的精力 是你不必要產出特定集合API Fosters software reuse by providing a standard interface for collections and algorithms with which to manipulate them. 促進軟體的複用 為集合提供一個基本的接口和操作他們的算法 The collections framework consists of:集合框架包含: Collection interfaces. Represent different types of collections, such as sets, lists, and maps. 集合接口. 描述不同的集合類型,如sets,lists,與mapsThese interfaces form the basis of the framework.這些接口表單基於框架. General-purpose implementations. Primary implementations of the collection interfaces. 通用實現. 主要的集合接口實現 Legacy implementations. The collection classes from earlier releases, Vector and Hashtable, were retrofitted to implement the collection interfaces. 遺留實現. 早期的releases版本的集合類,Vector,Hashtable被重新實現了集合接口. Special-purpose implementations. Implementations designed for use in special situations. 特定實現. 被設計的實現用於特定的狀況.These implementations display nonstandard performance characteristics, usage restrictions, or behavior.這些實現展示了非標準的執行字符,使用限制或行為. Concurrent implementations. Implementations designed for highly concurrent use. 並發的實現. 實現被設計應用於高並發. Wrapper implementations. Add functionality, such as synchronization, to other implementations. 包裝的實現. 為其他實現添加功能,例如synchronization. Convenience implementations. High-performance “mini-implementations” of the collection interfaces. 便捷的實現. 高性能的集合接口的“小實現”. Abstract implementations. Partial implementations of the collection interfaces to facilitate custom implementations. 抽象的實現. 局部的集合的實現促進定制的實現. Algorithms. Static methods that perform useful functions on collections, such as sorting a list. 算法. 在集合中存在靜態的對平台有用的方法,例如排序的list. Infrastructure. Interfaces that provide essential support for the collection interfaces. 底層 接口針對於集合接口的私有的必要支持. Array Utilities. Utility functions for arrays of primitive types and reference objects. 數組工具 針對於原始類型的數組和引用實體的工具方法.Not, strictly speaking, a part of the collections framework,哦,不，嚴格的來說,是集合框架的一部分,this feature was added to the Java platform at the same time as the collections framework and relies on some of the same infrastructure.這些特色是在同一時間作為集合框架和可信賴的一些相同的底層被添加於JAVA平台的.Collection Interfaces The collection interfaces are divided into two groups.集合接口被分為兩組.The most basic interface, java.util.Collection, has the following descendants:最基礎的接口,java.util.Collection,包含了以下子節點: 12345678java.util.Setjava.util.SortedSetjava.util.NavigableSetjava.util.Queuejava.util.concurrent.BlockingQueuejava.util.concurrent.TransferQueuejava.util.Dequejava.util.concurrent.BlockingDeque The other collection interfaces are based on java.util.Map and are not true collections.另外的集合接口以 java.util.Map 為基礎並不是一個真實的集合.However, these interfaces contain collection-view operations,儘管如此,這些接口包含了集合視圖操作,which enable them to be manipulated as collections.能夠使得他們像集合一樣備操作.Map has the following offspring:Map有以下子節點: 1234java.util.SortedMapjava.util.NavigableMapjava.util.concurrent.ConcurrentMapjava.util.concurrent.ConcurrentNavigableMap Many of the modification methods in the collection interfaces are labeled optional.在集合接口中許多修改的方法被標記為可選的.Implementations are permitted to not perform one or more of these operations,實現是被准許不執行這些操作中的一個或更多,throwing a runtime exception (UnsupportedOperationException) if they are attempted.如果他們被企圖則會拋出一個運行時異常(不被支持的操作異常).The documentation for each implementation must specify which optional operations are supported.每一個實現文檔必須制定哪一個可選的操作是被支持的.Several terms are introduced to aid in this specification:在這個說明中幾個術語有助於被介紹: Collections that do not support modification operations (such as add, remove and clear) are referred to as unmodifiable.不支持修改操作的集合(例如:add,remove,clear)作為不可修改的參考.Collections that are not unmodifiable are modifiable.可修改的集合是可修改的. Collections that additionally guarantee that no change in the Collection object will be visible are referred to as immutable.集合實體中無變化的額外保證可視化的集合是不可變的參考.Collections that are not immutable are mutable.可變的集合是可改變的. Lists that guarantee that their size remains constant even though the elements can change are referred to as fixed-size.保證儘管元素能改變但是他們的大小是恆定的列表是固定大小的參考.Lists that are not fixed-size are referred to as variable-size.不是固定大小的列表是可變大小的參考. Lists that support fast (generally constant time) indexed element access are known as random access lists.支持快速(恆定時間)索引元素訪問的列表作為一個隨機訪問的列表被了解.Lists that do not support fast indexed element access are known as sequential access lists.不支持快速索引元素訪問的列表做為一個連續訪問的列表被了解.The RandomAccess marker interface enables lists to advertise the fact that they support random access.隨機訪問標籤接口能夠使得列表突出他們支持隨機訪問的事實.This enables generic algorithms to change their behavior to provide good performance when applied to either random or sequential access lists.這使得通常的算法改變他們的習慣當申請隨機或序列的訪問列表時提供好的性能. Some implementations restrict what elements (or in the case of Maps, keys and values) can be stored.一些實現限定元素(或者Maps的類型,鍵,值)別存儲.Possible restrictions include requiring elements to:也許限定包含必須的元素: Be of a particular type.一個特殊的類型. Be not null.不能為空. Obey some arbitrary predicate.遵從一些特定的術語. Attempting to add an element that violates an implementation’s restrictions results in a runtime exception,嘗試添加一個違反一個實現限制元素的結果元素在運行時異常中,typically a ClassCastException, an IllegalArgumentException, or a NullPointerException.代表 ClassCastException, IllegalArgumentException, NullPointerException.Attempting to remove or test for the presence of an element that violates an implementation’s restrictions can result in an exception.嘗試溢出或者測試一個對於一個存在的違反實現限制元素的結果元素在一個異常中,Some restricted collections permit this usage.一些受限的集合允許這樣的使用.Collection Implementations Classes that implement the collection interfaces typically have names in the form of .實現了集合接口的類在表格中有特色名稱.The general purpose implementations are summarized in the following table:一般用途的實現總結如下表格: Interface Hash Table Resizable Array Balanced Tree Linked List Hash Table + Linked List Set HashSet TreeSet LinkedHashSet List ArrayList LinkedList Deque ArrayDeque LinkedList Map HashMap TreeMap LinkedHashMap The general-purpose implementations support all of the optional operations in the collection interfaces一般用途的實現支持所有在集合接口中的任意操作and have no restrictions on the elements they may contain.並且在他們所包含的元素中沒有限制條件.They are unsynchronized,他們是非同步化的,but the Collections class contains static factories called synchronization wrappers that can be used to add synchronization to many unsynchronized collections.但是集合類包含靜態的因子被同步封裝的能夠備用於添加同步化為許多非同步的集合.All of the new implementations have fail-fast iterators,所有新的實現都包含fail-fast迭代器,which detect invalid concurrent modification, and fail quickly and cleanly (rather than behaving erratically).監視無效的並發修改,快速失敗以及清除(而不是不規律的表現) The AbstractCollection, AbstractSet, AbstractList, AbstractSequentialList and AbstractMap classes抽象的 AbstractCollection, AbstractSet, AbstractList, AbstractSequentialList 以及 AbstractMap 類provide basic implementations of the core collection interfaces,准許基本的核心接口的實現,to minimize the effort required to implement them.最小化必須實現他們的精力.The API documentation for these classes describes precisely how each method is implemented so the implementer knows which methods must be overridden,API文檔對於這些類精準的描述了每一個方法是如何被實現的如實現者知道哪個方法必須被複寫,given the performance of the basic operations of a specific implementation.給性能一個基本的的操作基於特定的實現.Concurrent Collections Applications that use collections from more than one thread must be carefully programmed.應用多餘一條線程的應用程序必須被小心的編寫.In general, this is known as concurrent programming.通常,這是被了解的作為並發編程.The Java platform includes extensive support for concurrent programming.JAVA平台包含應用於支持並發編程的擴展.See Java Concurrency Utilities for details.細節請查看JAVA並發工具. Collections are so frequently used that various concurrent friendly interfaces and implementations of collections are included in the APIs.集合被如此頻繁的用於友好的接口及集合的實現包含其中的多變的並發中.These types go beyond the synchronization wrappers discussed previously to provide features that are frequently needed in concurrent programming.這些類型超出先前討論的提供給將來的頻繁應用於並發編程的同步封裝.These concurrent-aware interfaces are available:這些並發知識是可以獲取的: BlockingQueue TransferQueue BlockingDeque ConcurrentMap ConcurrentNavigableMap The following concurrent-aware implementation classes are available.包含並發知識的實現類是可獲取的.See the API documentation for the correct usage of these implementations.針對於正確使用這些實現請查看API文檔. LinkedBlockingQueue ArrayBlockingQueue PriorityBlockingQueue DelayQueue SynchronousQueue LinkedBlockingDeque LinkedTransferQueue CopyOnWriteArrayList CopyOnWriteArraySet ConcurrentSkipListSet ConcurrentHashMap ConcurrentSkipListMapDesign Goals The main design goal was to produce an API that was small in size and, more importantly, in “conceptual weight”.主要的公共設計是創建一個在大小上更小的,在概念重要性上更重要的API.It was critical that the new functionality not seem too different to current Java programmers;他是重要的在新的功能上是的當前JAVA開發人員開起來不是太難;it had to augment current facilities, rather than replace them.他增加當前的條件,而不是替換他們.At the same time, the new API had to be powerful enough to provide all the advantages described previously.與此同時,新的API使得所有以前的有益的描述更加的給力. To keep the number of core interfaces small,保持大量的核心小接口,the interfaces do not attempt to capture such subtle distinctions as mutability, modifiability, and resizability.這些接口不能嘗試捕獲諸如異變的,可編輯的以及真實的細小的描述,Instead, certain calls in the core interfaces are optional,與之替換的,確保呼叫核心接口是可選的,enabling implementations to throw an UnsupportedOperationException to indicate that they do not support a specified optional operation.授權實現拋出UnsupportedOperationException異常來表明他們不能支持一個特定的可選的操作.Collection implementers must clearly document which optional operations are supported by an implementation.集合實現必須明確文檔表名可選的操作是被支持于一個實現的. To keep the number of methods in each core interface small, an interface contains a method only if either:保持大量的方法在每一個核心的小接口內,一個接口包含一個方法當且僅當: It is a truly fundamental operation: a basic operations in terms of which others could be reasonably defined,他是一個真實的基本操作:一組其他的可被作為結果定義的一個基礎的操作 There is a compelling performance reason why an important implementation would want to override it.一個強制的平台原因一個重要的實現想要複寫他 It was critical that all reasonable representations of collections interoperate well.他是起決定性作用的在所有合理的集合很好交互的代表中.This included arrays, which cannot be made to implement the Collection interface directly without changing the language.這個包含不能實現集合接口確保不能改變語言的數組.Thus, the framework includes methods to enable collections to be moved into arrays,因此,這個框架包含的放阿飛能夠使得集合被移入數組,arrays to be viewed as collections, and maps to be viewed as collections.數組能夠備看做為集合,以及Map可以被看作為集合. 官方API頁面http://docs.oracle.com/javase/7/docs/technotes/guides/collections/overview.html截圖:]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
        <tag>TRANSLATING</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Platform Standard Edition 7 Documentation 總覽]]></title>
    <url>%2Farchives%2F%E6%8A%80%E8%A1%93%2F2015%2F11%2F24%2FJava-Platform-Standard-Edition-7-Documentation.html</url>
    <content type="text"><![CDATA[簡介：JDK 1.7 英文版 架構圖總覽今天開始系統學習JDK 1.7 API，使用文檔為ORACLE官方英文文檔相關源碼分析及詳細api文檔移路→JDK 1.7 SRC https://github.com/myhongkongzhen/pro-study-jdk/ 在線地址http://docs.oracle.com/javase/7/docs/]]></content>
      <categories>
        <category>技術</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JDK1.7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博文搬家GitHub]]></title>
    <url>%2Farchives%2F%E5%85%B6%E4%BB%96%2F2015%2F11%2F20%2FThe-First-Github-Blog.html</url>
    <content type="text"><![CDATA[簡介：初次使用GitHub博文系統 將博文搬家到GitHub，挑來挑去，結果發現以前的博客並沒有太多值的保留的文字，但是不留下來點又覺得可惜，挑幾篇放到這裡作為第一篇博文吧。元技術博文 substring与split的效率问题 TOMCAT配置文件配置字符編碼 struts2得到request對象 發現工作六七年了，像樣子的技術博文真是少的可憐，GitHub也是剛剛開始使用，並在此上建立了新博客通道，希望以後能回歸初心吧。]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>other</tag>
        <tag>backup</tag>
      </tags>
  </entry>
</search>